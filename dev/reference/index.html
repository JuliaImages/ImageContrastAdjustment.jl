<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Function References · Documentation</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>Documentation</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">ImageContrastAdjustment.jl Documentation</a></li><li class="current"><a class="toctext" href>Function References</a><ul class="internal"><li><a class="toctext" href="#General-function-1">General function</a></li><li><a class="toctext" href="#Algorithms-1">Algorithms</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Function References</a></li></ul><a class="edit-page" href="https://github.com/zygmuntszpak/ImageContrastAdjustment.jl/blob/master/docs/src/reference.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Function References</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="function_reference-1" href="#function_reference-1">Function References</a></h1><ul><li><a href="#function_reference-1">Function References</a></li><ul><li><a href="#General-function-1">General function</a></li><li><a href="#Algorithms-1">Algorithms</a></li><ul><li><a href="#ContrastStretching-1">ContrastStretching</a></li><li><a href="#Equalization-1">Equalization</a></li><li><a href="#LinearStretching-1">LinearStretching</a></li><li><a href="#Matching-1">Matching</a></li><li><a href="#MidwayEqualization-1">MidwayEqualization</a></li></ul></ul></ul><h2><a class="nav-anchor" id="General-function-1" href="#General-function-1">General function</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ImageContrastAdjustment.HistogramAdjustmentAPI.adjust_histogram" href="#ImageContrastAdjustment.HistogramAdjustmentAPI.adjust_histogram"><code>ImageContrastAdjustment.HistogramAdjustmentAPI.adjust_histogram</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">adjust_histogram([T::Type,] img, f::AbstractHistogramAdjustmentAlgorithm, args...; kwargs...)</code></pre><p>Adjust histogram of <code>img</code> using algorithm <code>f</code>.</p><p><strong>Output</strong></p><p>The return image <code>img_adjusted</code> is an <code>Array{T}</code>.</p><p>If <code>T</code> is not specified, then it&#39;s inferred.</p><p><strong>Examples</strong></p><p>Just simply pass the input image and algorithm to <code>adjust_histogram</code></p><pre><code class="language-julia">img_adjusted = adjust_histogram(img, f)</code></pre><p>This reads as &quot;<code>adjust_histogram</code> of image <code>img</code> using algorithm <code>f</code>&quot;.</p><p>You can also explicitly specify the return type:</p><pre><code class="language-julia">img_adjusted_float32 = adjust_histogram(Gray{Float32}, img, f)</code></pre><p>See also <a href="#ImageContrastAdjustment.HistogramAdjustmentAPI.adjust_histogram!"><code>adjust_histogram!</code></a> for in-place histogram adjustment.</p></div></div><a class="source-link" target="_blank" href="https://github.com/zygmuntszpak/ImageContrastAdjustment.jl/blob/a7a1fe86cdb6ef6eaad9314bda2b9d4ba720dc64/src/HistogramAdjustmentAPI/histogram_adjustment.jl#L148-L175">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ImageContrastAdjustment.HistogramAdjustmentAPI.adjust_histogram!" href="#ImageContrastAdjustment.HistogramAdjustmentAPI.adjust_histogram!"><code>ImageContrastAdjustment.HistogramAdjustmentAPI.adjust_histogram!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">adjust_histogram!([out,] img, f::AbstractHistogramAdjustmentAlgorithm, args...; kwargs...)</code></pre><p>Adjust histogram of <code>img</code> using algorithm <code>f</code>.</p><p><strong>Output</strong></p><p>If <code>out</code> is specified, it will be changed in place. Otherwise <code>img</code> will be changed in place.</p><p><strong>Examples</strong></p><p>Just simply pass an algorithm to <code>adjust_histogram!</code>:</p><pre><code class="language-julia">img_adjusted = similar(img)
adjust_histogram!(img_adjusted, img, f)</code></pre><p>For cases you just want to change <code>img</code> in place, you don&#39;t necessarily need to manually allocate <code>img_adjusted</code>; just use the convenient method:</p><pre><code class="language-julia">adjust_histogram!(img, f)</code></pre><p>See also: <a href="#ImageContrastAdjustment.HistogramAdjustmentAPI.adjust_histogram"><code>adjust_histogram</code></a></p></div></div><a class="source-link" target="_blank" href="https://github.com/zygmuntszpak/ImageContrastAdjustment.jl/blob/a7a1fe86cdb6ef6eaad9314bda2b9d4ba720dc64/src/HistogramAdjustmentAPI/histogram_adjustment.jl#L119-L145">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ImageContrastAdjustment.build_histogram" href="#ImageContrastAdjustment.build_histogram"><code>ImageContrastAdjustment.build_histogram</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">edges, count = build_histogram(img, nbins)
edges, count = build_histogram(img, nbins; minval, maxval)
edges, count = build_histogram(img, edges)</code></pre><p>Generates a histogram for the image over <code>nbins</code> spread between <code>[minval, maxval]</code>. Color images are automatically converted to grayscale.</p><p><strong>Output</strong></p><p>Returns <code>edges</code> which is a <code>AbstractRange</code> type that specifies how the  interval <code>[minval, maxval]</code> is divided into bins, and an array <code>count</code> which records the concomitant bin frequencies. In particular, <code>count</code> has the following properties:</p><ul><li><code>count[0]</code> is the number satisfying <code>x &lt; edges[1]</code></li><li><code>count[i]</code> is the number of values <code>x</code> that satisfy <code>edges[i] &lt;= x &lt; edges[i+1]</code></li><li><code>count[end]</code> is the number satisfying <code>x &gt;= edges[end]</code>.</li><li><code>length(count) == length(edges)+1</code>.</li></ul><p><strong>Details</strong></p><p>One can consider a histogram as a piecewise-constant model of a probability density function <span>$f$</span> [1]. Suppose that <span>$f$</span> has support on some interval <span>$I = [a,b]$</span>.  Let <span>$m$</span> be an integer and <span>$a = a_1 &lt; a_2 &lt; \ldots &lt; a_m &lt; a_{m+1} = b$</span> a sequence of real numbers. Construct a sequence of intervals</p><div>\[I_1 = [a_1,a_2], I_2 = (a_2, a_3], \ldots, I_{m} = (a_m,a_{m+1}]\]</div><p>which partition <span>$I$</span> into subsets <span>$I_j$</span> <span>$(j = 1, \ldots, m)$</span> on which <span>$f$</span> is constant. These subsets satisfy <span>$I_i \cap I_j = \emptyset, \forall i \neq j$</span>, and are commonly referred to as <em>bins</em>. Together they encompass the entire range of data values such that <span>$\sum_j |I_j | = | I |$</span>. Each bin has width <span>$w_j = |I_j| = a_{j+1} - a_j$</span> and height <span>$h_j$</span> which is the constant probability density over the region of the bin. Integrating the constant probability density over the width of the bin <span>$w_j$</span> yields a probability mass of <span>$\pi_j = h_j w_j$</span> for the bin.</p><p>For a sample <span>$x_1, x_2, \ldots, x_N$</span>, let</p><div>\[n_j = \sum_{n = 1}^{N}\mathbf{1}_{(I_j)}(x_n),
\quad \text{where} \quad
\mathbf{1}_{(I_j)}(x) =
\begin{cases}
 1 &amp; \text{if} \; x \in I_j,\\
 0 &amp; \text{otherwise},
\end{cases},\]</div><p>represent the number of samples falling into the interval <span>$I_j$</span>. An estimate for the probability mass of the <span>$j$</span>th bin is given by the relative frequency <span>$\hat{\pi} = \frac{n_j}{N}$</span>, and the histogram estimator of the probability density function is defined as</p><div>\[\begin{aligned}
\hat{f}_n(x)  &amp; = \sum_{j = 1}^{m}\frac{n_j}{Nw_j} \mathbf{1}_{(I_j)}(x) \\
&amp; = \sum_{j = 1}^{m}\frac{\hat{\pi}_j}{w_j} \mathbf{1}_{(I_j)}(x) \\
&amp; = \sum_{j = 1}^{m}\hat{h}_j \mathbf{1}_{(I_j)}(x).
\end{aligned}\]</div><p>The function <span>$\hat{f}_n(x)$</span> is a genuine density estimator because <span>$\hat{f}_n(x)  \ge 0$</span> and</p><div>\[\begin{aligned}
\int_{-\infty}^{\infty}\hat{f}_n(x) \operatorname{d}x &amp; = \sum_{j=1}^{m} \frac{n_j}{Nw_j} w_j \\
&amp; = 1.
\end{aligned}\]</div><p><strong>Options</strong></p><p>Various options for the parameters of this function are described in more detail below.</p><p><strong>Choices for <code>nbins</code></strong></p><p>You can specify the number of discrete bins for the histogram. When specifying the number of bins consider the maximum number of graylevels that your image type supports. For example, with an image of type <code>N0f8</code> there is a maximum of 256 possible graylevels. Hence, if you request more than 256 bins for that type of image you should expect to obtain zero counts for numerous bins.</p><p><strong>Choices for <code>minval</code></strong></p><p>You have the option to specify the lower bound of the interval over which the histogram will be computed.  If <code>minval</code> is not specified then the minimum value present in the image is taken as the lower bound.</p><p><strong>Choices for <code>maxval</code></strong></p><p>You have the option to specify the upper bound of the interval over which the histogram will be computed.  If <code>maxval</code> is not specified then the maximum value present in the image is taken as the upper bound.</p><p><strong>Choices for <code>edges</code></strong></p><p>If you do not designate the number of bins, nor the lower or upper bound of the interval, then you have the option to directly stipulate how the intervals will be divided by specifying a <code>AbstractRange</code> type.</p><p><strong>Example</strong></p><p>Compute the histogram of a grayscale image.</p><pre><code class="language-julia">
using TestImages, FileIO, ImageView

img =  testimage(&quot;mandril_gray&quot;);
edges, counts  = build_histogram(img, 256, minval = 0, maxval = 1)</code></pre><p>Given a color image, compute the histogram of the red channel.</p><pre><code class="language-julia">img = testimage(&quot;mandrill&quot;)
r = red.(img)
edges, counts  = build_histogram(r, 256, minval = 0, maxval = 1)</code></pre><p><strong>References</strong></p><p>[1] E. Herrholz, &quot;Parsimonious Histograms,&quot; Ph.D. dissertation, Inst. of Math. and Comp. Sci., University of Greifswald, Greifswald, Germany, 2011.</p></div></div><a class="source-link" target="_blank" href="https://github.com/zygmuntszpak/ImageContrastAdjustment.jl/blob/a7a1fe86cdb6ef6eaad9314bda2b9d4ba720dc64/src/build_histogram.jl#L9-L129">source</a></section><h2><a class="nav-anchor" id="Algorithms-1" href="#Algorithms-1">Algorithms</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ImageContrastAdjustment.HistogramAdjustmentAPI.AbstractHistogramAdjustmentAlgorithm" href="#ImageContrastAdjustment.HistogramAdjustmentAPI.AbstractHistogramAdjustmentAlgorithm"><code>ImageContrastAdjustment.HistogramAdjustmentAPI.AbstractHistogramAdjustmentAlgorithm</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">AbstractHistogramAdjustmentAlgorithm &lt;: AbstractImageFilter</code></pre><p>The root type for <code>ImageContrastAdjustment</code> package.</p><p>Any concrete histogram adjustment algorithm shall subtype it to support <a href="#ImageContrastAdjustment.HistogramAdjustmentAPI.adjust_histogram"><code>adjust_histogram</code></a> and <a href="#ImageContrastAdjustment.HistogramAdjustmentAPI.adjust_histogram!"><code>adjust_histogram!</code></a> APIs.</p><p><strong>Examples</strong></p><p>All histogram adjustment algorithms in ImageContrastAdjustment are called in the following pattern:</p><pre><code class="language-julia"># first generate an algorithm instance
f = LinearStretching()

# then pass the algorithm to `adjust_histogram`
img_adjusted = adjust_histogram(img, f)

# or use in-place version `adjust_histogram!`
img_adjusted = similar(img)
adjust_histogram!(img_adjusted, img, f)</code></pre><p>Some algorithms also receive additional information as an argument, e.g., <code>nbins</code> of <code>Equalization</code>.</p><pre><code class="language-julia"># you can explicit specify the parameters
f = Equalization(nbins = 32)</code></pre><p>For more examples, please check <a href="#ImageContrastAdjustment.HistogramAdjustmentAPI.adjust_histogram"><code>adjust_histogram</code></a>, <a href="#ImageContrastAdjustment.HistogramAdjustmentAPI.adjust_histogram!"><code>adjust_histogram!</code></a> and concrete algorithms.</p></div></div><a class="source-link" target="_blank" href="https://github.com/zygmuntszpak/ImageContrastAdjustment.jl/blob/a7a1fe86cdb6ef6eaad9314bda2b9d4ba720dc64/src/HistogramAdjustmentAPI/histogram_adjustment.jl#L6-L41">source</a></section><h3><a class="nav-anchor" id="ContrastStretching-1" href="#ContrastStretching-1">ContrastStretching</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ImageContrastAdjustment.ContrastStretching" href="#ImageContrastAdjustment.ContrastStretching"><code>ImageContrastAdjustment.ContrastStretching</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">    ContrastStretching &lt;: AbstractHistogramAdjustmentAlgorithm
    ContrastStretching(; t = 0.5,  slope = 1.0)

    adjust_histogram([T,] img, f::ContrastStretching)
    adjust_histogram!([out,] img, f::ContrastStretching)</code></pre><p>Returns an image where intensities below <code>t</code> are compressed into a narrower range of dark intensities, and values above <code>t</code> are compressed into a narrower band of light intensities.</p><p><strong>Details</strong></p><p>Contrast stretching is a transformation that  enhances or reduces (for <code>slope</code> &gt; 1 or &lt; 1, respectively) the contrast near saturation (0 and 1). It is given by the relation</p><div>\[f(x) = \frac{1}{1 + \left(\frac{t}{x} \right)^s}, \; s \in \mathbb{R},\]</div><p>where <span>$s$</span> represents the <code>slope</code> argument.</p><p><strong>Options</strong></p><p>Various options for the parameters of the <code>adjust_histogram</code> and <code>ContrastStretching</code> type are described in more detail below.</p><p><strong>Choices for <code>img</code></strong></p><p>The function can handle a variety of input types. The returned image depends on the input type.</p><p>For colored images, the input is converted to the <a href="https://en.wikipedia.org/wiki/YIQ">YIQ</a>  type and the intensities of the Y channel are stretched to the specified range. The modified Y channel is then combined with the I and Q channels and the resulting image converted to the same type as the input.</p><p><strong>Choice for <code>t</code></strong></p><p>The value of <code>t</code> needs to be in the unit interval. If left unspecified a default value of 0.5 is utilized.</p><p><strong>Choice for <code>slope</code></strong></p><p>The value of <code>slope</code> can be any real number. If left unspecified a default value of 1.0 is utilized.</p><p><strong>Example</strong></p><pre><code class="language-julia">using ImageContrastAdjustment, ImageView, TestImages

img = testimage(&quot;mandril_gray&quot;)
ret = adjust_histogram(img, ContrastStretching(t = 0.6, slope = 3))
</code></pre><p><strong>References</strong></p><ol><li>Gonzalez, R. C., Woods, R. E., &amp; Eddins, S. L. (2004). <em>Digital image processing using MATLAB</em> (Vol. 624). Upper Saddle River, New Jersey: Pearson-Prentice-Hall.</li></ol></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/80516ca20297a67b996caa08c38786332379b6a5/base/#L0-L62">source</a></section><h3><a class="nav-anchor" id="Equalization-1" href="#Equalization-1">Equalization</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ImageContrastAdjustment.Equalization" href="#ImageContrastAdjustment.Equalization"><code>ImageContrastAdjustment.Equalization</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">    Equalization &lt;: AbstractHistogramAdjustmentAlgorithm
    Equalization(; nbins = 256, minval = 0, maxval = 1)

    adjust_histogram([T,] img, f::Equalization)
    adjust_histogram!([out,] img, f::Equalization)</code></pre><p>Returns a histogram equalized image with a granularity of <code>nbins</code> number of bins.</p><p><strong>Details</strong></p><p>Histogram equalization was initially conceived to  improve the contrast in a single-channel grayscale image. The method transforms the distribution of the intensities in an image so that they are as uniform as possible [1]. The natural justification for uniformity is that the image has better contrast  if the intensity levels of an image span a wide range on the intensity scale. As it turns out, the necessary transformation is a mapping based on the cumulative histogram.</p><p>One can consider an <span>$L$</span>-bit single-channel <span>$I \times J$</span> image with gray values in the set <span>$\{0,1,\ldots,L-1 \}$</span>, as a collection of independent and identically distributed random variables. Specifically, let the sample space <span>$\Omega$</span> be the set of all <span>$IJ$</span>-tuples <span>$\omega =(\omega_{11},\omega_{12},\ldots,\omega_{1J},\omega_{21},\omega_{22},\ldots,\omega_{2J},\omega_{I1},\omega_{I2},\ldots,\omega_{IJ})$</span>, where each <span>$\omega_{ij} \in \{0,1,\ldots, L-1 \}$</span>. Furthermore, impose a probability measure on <span>$\Omega$</span> such that the functions <span>$\Omega \ni \omega \to \omega_{ij} \in \{0,1,\ldots,L-1\}$</span> are independent and identically distributed.</p><p>One can then regard an image as a matrix of random variables <span>$\mathbf{G} = [G_{i,j}(\omega)]$</span>, where each function <span>$G_{i,j}: \Omega \to \mathbb{R}$</span> is defined by</p><div>\[G_{i,j}(\omega) = \frac{\omega_{ij}}{L-1},\]</div><p>and each <span>$G_{i,j}$</span> is distributed according to some unknown density <span>$f_{G}$</span>. While <span>$f_{G}$</span> is unknown, one can approximate it with a normalized histogram of gray levels,</p><div>\[\hat{f}_{G}(v)= \frac{n_v}{IJ},\]</div><p>where</p><div>\[n_v = \left | \left\{(i,j)\, |\,  G_{i,j}(\omega)  = v \right \} \right |\]</div><p>represents the number of times a gray level with intensity <span>$v$</span> occurs in <span>$\mathbf{G}$</span>. To transform the distribution of the intensities so that they are as uniform as possible one needs to find a mapping <span>$T(\cdot)$</span> such that <span>$T(G_{i,j}) \thicksim U$</span>. The required mapping turns out to be the cumulative distribution function (CDF) of the empirical density <span>$\hat{f}_{G}$</span>,</p><div>\[ T(G_{i,j}) = \int_0^{G_{i,j}}\hat{f}_{G}(w)\mathrm{d} w.\]</div><p><strong>Options</strong></p><p>Various options for the parameters of the <code>adjust_histogram</code> function and <code>Equalization</code> type are described in more detail below.</p><p><strong>Choices for <code>img</code></strong></p><p>The <code>adjust_histogram</code> function can handle a variety of input types.  By default type of the returned image matches the input type.</p><p>For colored images, the input is converted to <a href="https://en.wikipedia.org/wiki/YIQ">YIQ</a> type and the Y channel is equalized. This is the combined with the I and Q channels and the resulting image converted to the same type as the input.</p><p><strong>Choices for <code>nbins</code> in <code>Equalization</code></strong></p><p>You can specify the total number of bins in the histogram.</p><p><strong>Choices for <code>minval</code> and <code>maxval</code> in <code>Equalization</code></strong></p><p>If <code>minval</code> and <code>maxval</code> are specified then intensities are equalized to the range [<code>minval</code>, <code>maxval</code>]. The default values are 0 and 1.</p><p><strong>Example</strong></p><pre><code class="language-julia">
using TestImages, FileIO, ImageView

img =  testimage(&quot;mandril_gray&quot;)
imgeq = adjust_histogram(img, Equalization(nbins = 256, minval = 0, maxval = 1))

imshow(img)
imshow(imgeq)</code></pre><p><strong>References</strong></p><ol><li>R. C. Gonzalez and R. E. Woods. <em>Digital Image Processing (3rd Edition)</em>.  Upper Saddle River, NJ, USA: Prentice-Hall,  2006.</li></ol></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/80516ca20297a67b996caa08c38786332379b6a5/base/#L0-L97">source</a></section><h3><a class="nav-anchor" id="LinearStretching-1" href="#LinearStretching-1">LinearStretching</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ImageContrastAdjustment.LinearStretching" href="#ImageContrastAdjustment.LinearStretching"><code>ImageContrastAdjustment.LinearStretching</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">    LinearStretching &lt;: AbstractHistogramAdjustmentAlgorithm
    LinearStretching(; minval = 0, maxval = 1)

    adjust_histogram([T,] img, f::LinearStretching)
    adjust_histogram!([out,] img, f::LinearStretching)</code></pre><p>Returns an image where the range of the intensities spans the interval [<code>minval</code>, <code>maxval</code>].</p><p><strong>Details</strong></p><p>Linear stretching (also called <em>normalization</em>) is a contrast enhancing transformation that is used to modify the dynamic range of the image. In particular, suppose that the input image has gray values in the range [A,B] and one wishes to change the dynamic range to [a,b] using a linear mapping, then the necessary transformation is given by the relation</p><div>\[f(x) = (x-A) \frac{b-a}{B-A} + a.\]</div><p><strong>Options</strong></p><p>Various options for the parameters of the <code>adjust_histogram</code> and <code>LinearStretching</code> type  are described in more detail below.</p><p><strong>Choices for <code>img</code></strong></p><p>The function can handle a variety of input types. The returned image depends on the input type.</p><p>For colored images, the input is converted to the <a href="https://en.wikipedia.org/wiki/YIQ">YIQ</a>  type and the intensities of the Y channel are stretched to the specified range. The modified Y channel is then combined with the I and Q channels and the resulting image converted to the same type as the input.</p><p><strong>Choices for <code>minval</code> and <code>maxval</code></strong></p><p>If minval and maxval are specified then intensities are mapped to the range [<code>minval</code>, <code>maxval</code>]. The default values are 0 and 1.</p><p><strong>Example</strong></p><pre><code class="language-julia">using ImageContrastAdjustment, ImageView, TestImages

img = testimage(&quot;mandril_gray&quot;)
imgo = adjust_histogram(img, LinearStretching(minval = 0, maxval = 1))
</code></pre><p><strong>References</strong></p><ol><li>W. Burger and M. J. Burge. <em>Digital Image Processing</em>. Texts in Computer Science, 2016. <a href="https://doi.org/10.1007/978-1-4471-6684-9">doi:10.1007/978-1-4471-6684-9</a></li></ol></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/80516ca20297a67b996caa08c38786332379b6a5/base/#L0-L58">source</a></section><h3><a class="nav-anchor" id="Matching-1" href="#Matching-1">Matching</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ImageContrastAdjustment.Matching" href="#ImageContrastAdjustment.Matching"><code>ImageContrastAdjustment.Matching</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">    Matching &lt;: AbstractHistogramAdjustmentAlgorithm
    Matching(targetimg; nbins = 256, edges = nothing)

    adjust_histogram([T,] img, f::Matching)
    adjust_histogram!([out,] img, f::Matching)</code></pre><p>Returns a histogram matched image with a granularity of <code>nbins</code> number of bins. The first argument <code>img</code> is the image to be matched, whereas the argument <code>targetimg</code> in <code>Matching()</code> is the image having the desired histogram to be matched to.</p><p><strong>Details</strong></p><p>The purpose of histogram matching is to transform the intensities in a source image so that the intensities distribute according to the histogram of a specified target image. If one interprets histograms as piecewise-constant models of probability density functions (see <a href="#ImageContrastAdjustment.build_histogram"><code>build_histogram</code></a>), then the histogram matching task can be modelled as the problem of transforming one probability distribution into another [1]. It turns out that the solution to this transformation problem involves the cumulative and inverse cumulative distribution functions of the source and target probability density functions.</p><p>In particular, let the random variables <span>$x \thicksim p_{x}$</span> and <span>$z \thicksim p_{z}$</span>  represent an intensity in the source and target image respectively, and let</p><div>\[ S(x) = \int_0^{x}p_{x}(w)\mathrm{d} w \quad \text{and} \quad
 T(z) = \int_0^{z}p_{z}(w)\mathrm{d} w\]</div><p>represent their concomitant cumulative distribution functions. Then the sought-after mapping <span>$Q(\cdot)$</span> such that <span>$Q(x) \thicksim p_{z}$</span> is given by</p><div>\[Q(x) =  T^{-1}\left( S(x) \right),\]</div><p>where <span>$T^{-1}(y) = \operatorname{min} \{ x \in \mathbb{R} : y \leq T(x) \}$</span> is the inverse cumulative distribution function of <span>$T(x)$</span>.</p><p>The mapping suggests that one can conceptualize histogram matching as performing histogram equalization on the source and target image and relating the two equalized histograms. Refer to <a href="#ImageContrastAdjustment.HistogramAdjustmentAPI.adjust_histogram"><code>adjust_histogram</code></a> for more details on histogram equalization.</p><p><strong>Options</strong></p><p>Various options for the parameters of the <code>adjust_histogram</code> function and <code>Matching</code> type are described in more detail below.</p><p><strong>Choices for <code>img</code> and <code>targetimg</code></strong></p><p>The <code>adjust_histogram(img, Matching())</code> function can handle a variety of input types. The type of the returned image matches the input type.</p><p>For colored images, the inputs are converted to <a href="https://en.wikipedia.org/wiki/YIQ">YIQ</a>  type and the distributions of the Y channels are matched. The modified Y channel is then combined with the I and Q channels and the resulting image converted to the same type as the input.</p><p><strong>Choices for <code>nbins</code></strong></p><p>You can specify the total number of bins in the histogram. If you do not specify the number of bins then a default value of 256 bins is utilized.</p><p><strong>Choices for <code>edges</code></strong></p><p>If you do not designate the number of bins, then you have the option to directly stipulate how the intervals will be divided by specifying a <code>AbstractRange</code> type.</p><p><strong>Example</strong></p><pre><code class="language-julia">using Images, TestImages, ImageView

img_source = testimage(&quot;mandril_gray&quot;)
img_target = adjust_gamma(img_source, 1/2)
img_transformed = adjust_histogram(img_source, Matching(targetimg = img_target))
#=
    A visual inspection confirms that img_transformed resembles img_target
    much more closely than img_source.
=#
imshow(img_source)
imshow(img_target)
imshow(img_transformed)</code></pre><p><strong>References</strong></p><ol><li>W. Burger and M. J. Burge. <em>Digital Image Processing</em>. Texts in Computer Science, 2016. <a href="https://doi.org/10.1007/978-1-4471-6684-9">doi:10.1007/978-1-4471-6684-9</a></li></ol></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/80516ca20297a67b996caa08c38786332379b6a5/base/#L0-L97">source</a></section><h3><a class="nav-anchor" id="MidwayEqualization-1" href="#MidwayEqualization-1">MidwayEqualization</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ImageContrastAdjustment.MidwayEqualization" href="#ImageContrastAdjustment.MidwayEqualization"><code>ImageContrastAdjustment.MidwayEqualization</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">    MidwayEqualization &lt;: AbstractHistogramAdjustmentAlgorithm
    MidwayEqualization(; nbins = 256, minval = 0, maxval = 1)

    adjust_histogram([T,] img_sequence, f::MidwayEqualization(nbins = 256, edges = nothing))
    adjust_histogram!([out_sequence,] img_sequence, f::MidwayEqualization(nbins = 256, edges = nothing))</code></pre><p>Gives a pair of images the same histogram whilst maintaining as much as possible their previous grey level dynamics.</p><p><strong>Details</strong></p><p>The purpose of midway histogram equalization is to transform the intensities in a pair of images so that the intensities distribute according to a common &quot;midway&quot; distribution. The histogram representing the common distribution is chosen so that the original  gray level dynamics of the images are preserved as much as possible. If one interprets histograms as piecewise-constant models of probability density functions (see <a href="#ImageContrastAdjustment.build_histogram"><code>build_histogram</code></a>), then the midway histogram equalization task can be modeled as the problem of transforming one probability distribution into another (see <a href="#ImageContrastAdjustment.HistogramAdjustmentAPI.adjust_histogram"><code>adjust_histogram</code></a>). It turns out that the solution to this transformation problem involves the cumulative and inverse cumulative distribution functions of the source and &quot;midway&quot; probability density functions. In particular, let the random variables <span>$X_i \thicksim p_{x_i} \; (i = 1,2)$</span>, and <span>$Z \thicksim p_{z}$</span>  represent an intensity in the first, second and &quot;midway&quot; image respectively, and let</p><div>\[ S_{X_i}(x) = \int_0^{x}p_{x_i}(w)\mathrm{d} w \; \quad \text{and} \quad
 T_{Z}(x) = \frac{2}{\frac{1}{S_{X_1}(x)} + \frac{1}{S_{X_2}(x)}}\]</div><p>represent the cumulative distribution functions of the two input images, and their <em>harmonic mean</em>, respectively. Then the sought-after mapping <span>$Q_{X_i}(\cdot)$</span> <span>$(i = 1,2)$</span> such that <span>$Q_{X_i}(x) \thicksim p_{z}$</span> is given by</p><div>\[Q_{X_i}(x) =  T_{Z}^{-1}\left( S_{X_i}(x) \right),\]</div><p>where <span>$T_{Z}^{-1}(y) = \operatorname{min} \{ x \in \mathbb{R} : y \leq T_{Z}(x) \}$</span> is the inverse cumulative distribution function of <span>$T_{Z}(x)$</span>.</p><p><strong>Options</strong></p><p>Various options for the parameters of the <code>adjust_histogram</code> function and <code>MidwayEqualization</code> types are described in more detail below.</p><p><strong>Choices for <code>img_sequence</code></strong></p><p>The function <code>adjust_histogram</code> expects a length-2 <code>Vector</code> of images (the pair of images) and returns a length-2 <code>Vector</code> of modified images.  The  function can handle a variety of input types. The type of the returned image matches the input type.</p><p>For colored images, the inputs are converted to <a href="https://en.wikipedia.org/wiki/YIQ">YIQ</a>  type and the distributions of the Y channels are transformed according to a &quot;midway&quot; distribution. The modified Y channel is then combined with the I and Q channels and the resulting image converted to the same type as the input.</p><p><strong>Choices for <code>nbins</code></strong></p><p>You can specify the total number of bins in the histogram. If you do not specify the number of bins then a default value of 256 bins is utilized.</p><p><strong>Choices for <code>edges</code></strong></p><p>If you do not designate the number of bins, then you have the option to directly stipulate how the intervals will be divided by specifying a <code>AbstractRange</code> type.</p><p><strong>Example</strong></p><pre><code class="language-julia">using Images, TestImages, ImageView, ImageContrastAdjustment

img = testimage(&quot;mandril_gray&quot;)

# The same image but with different intensitiy distributions
img1 = adjust_histogram(img, GammaCorrection(gamma = 2))
img2 = adjust_histogram(img, GammaCorrection(gamma = 1.2))

# Midway histogram equalization will transform these two images so that their
# intensity distributions are almost identical.
img_sequence = adjust_histogram([img1, img2], MidwayEqualization(nbins = 256))
img1o = first(img_sequence)
img2o = last(img_sequence)</code></pre><p><strong>References</strong></p><ol><li>T. Guillemot and J. Delon, “<em>Implementation of the Midway Image Equalization</em>,” Image Processing On Line, vol. 5, pp. 114–129, Jun. 2016. <a href="https://doi.org/10.5201/ipol.2016.140">doi:10.5201/ipol.2016.140</a></li></ol></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/80516ca20297a67b996caa08c38786332379b6a5/base/#L0-L96">source</a></section><footer><hr/><a class="previous" href="../"><span class="direction">Previous</span><span class="title">ImageContrastAdjustment.jl Documentation</span></a></footer></article></body></html>
