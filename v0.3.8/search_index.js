var documenterSearchIndex = {"docs":
[{"location":"reference/#function_reference-1","page":"Function References","title":"Function References","text":"","category":"section"},{"location":"reference/#","page":"Function References","title":"Function References","text":"Pages = [\"reference.md\"]\nDepth = 3","category":"page"},{"location":"reference/#General-function-1","page":"Function References","title":"General function","text":"","category":"section"},{"location":"reference/#","page":"Function References","title":"Function References","text":"adjust_histogram\nadjust_histogram!\nbuild_histogram","category":"page"},{"location":"reference/#ImageContrastAdjustment.HistogramAdjustmentAPI.adjust_histogram","page":"Function References","title":"ImageContrastAdjustment.HistogramAdjustmentAPI.adjust_histogram","text":"adjust_histogram([T::Type,] img, f::AbstractHistogramAdjustmentAlgorithm, args...; kwargs...)\n\nAdjust histogram of img using algorithm f.\n\nOutput\n\nThe return image img_adjusted is an Array{T}.\n\nIf T is not specified, then it's inferred.\n\nExamples\n\nJust simply pass the input image and algorithm to adjust_histogram\n\nimg_adjusted = adjust_histogram(img, f)\n\nThis reads as \"adjust_histogram of image img using algorithm f\".\n\nYou can also explicitly specify the return type:\n\nimg_adjusted_float32 = adjust_histogram(Gray{Float32}, img, f)\n\nSee also adjust_histogram! for in-place histogram adjustment.\n\n\n\n\n\n","category":"function"},{"location":"reference/#ImageContrastAdjustment.HistogramAdjustmentAPI.adjust_histogram!","page":"Function References","title":"ImageContrastAdjustment.HistogramAdjustmentAPI.adjust_histogram!","text":"adjust_histogram!([out,] img, f::AbstractHistogramAdjustmentAlgorithm, args...; kwargs...)\n\nAdjust histogram of img using algorithm f.\n\nOutput\n\nIf out is specified, it will be changed in place. Otherwise img will be changed in place.\n\nExamples\n\nJust simply pass an algorithm to adjust_histogram!:\n\nimg_adjusted = similar(img)\nadjust_histogram!(img_adjusted, img, f)\n\nFor cases you just want to change img in place, you don't necessarily need to manually allocate img_adjusted; just use the convenient method:\n\nadjust_histogram!(img, f)\n\nSee also: adjust_histogram\n\n\n\n\n\n","category":"function"},{"location":"reference/#ImageContrastAdjustment.build_histogram","page":"Function References","title":"ImageContrastAdjustment.build_histogram","text":"edges, count = build_histogram(img)            # For 8-bit images only\nedges, count = build_histogram(img, nbins)\nedges, count = build_histogram(img, nbins; minval, maxval)\nedges, count = build_histogram(img, edges)\n\nGenerates a histogram for the image over nbins spread between [minval, maxval]. Color images are automatically converted to grayscale.\n\nOutput\n\nReturns edges which is a AbstractRange type that specifies how the  interval [minval, maxval] is divided into bins, and an array count which records the concomitant bin frequencies. In particular, count has the following properties:\n\ncount[0] is the number satisfying x < edges[1]\ncount[i] is the number of values x that satisfy edges[i] <= x < edges[i+1]\ncount[end] is the number satisfying x >= edges[end].\nlength(count) == length(edges)+1.\n\nDetails\n\nOne can consider a histogram as a piecewise-constant model of a probability density function f [1]. Suppose that f has support on some interval I = ab.  Let m be an integer and a = a_1  a_2  ldots  a_m  a_m+1 = b a sequence of real numbers. Construct a sequence of intervals\n\nI_1 = a_1a_2 I_2 = (a_2 a_3 ldots I_m = (a_ma_m+1\n\nwhich partition I into subsets I_j (j = 1 ldots m) on which f is constant. These subsets satisfy I_i cap I_j = emptyset forall i neq j, and are commonly referred to as bins. Together they encompass the entire range of data values such that sum_j I_j  =  I . Each bin has width w_j = I_j = a_j+1 - a_j and height h_j which is the constant probability density over the region of the bin. Integrating the constant probability density over the width of the bin w_j yields a probability mass of pi_j = h_j w_j for the bin.\n\nFor a sample x_1 x_2 ldots x_N, let\n\nn_j = sum_n = 1^Nmathbf1_(I_j)(x_n)\nquad textwhere quad\nmathbf1_(I_j)(x) =\nbegincases\n 1  textif  x in I_j\n 0  textotherwise\nendcases\n\nrepresent the number of samples falling into the interval I_j. An estimate for the probability mass of the jth bin is given by the relative frequency hatpi = fracn_jN, and the histogram estimator of the probability density function is defined as\n\nbeginaligned\nhatf_n(x)   = sum_j = 1^mfracn_jNw_j mathbf1_(I_j)(x) \n = sum_j = 1^mfrachatpi_jw_j mathbf1_(I_j)(x) \n = sum_j = 1^mhath_j mathbf1_(I_j)(x)\nendaligned\n\nThe function hatf_n(x) is a genuine density estimator because hatf_n(x)  ge 0 and\n\nbeginaligned\nint_-infty^inftyhatf_n(x) operatornamedx  = sum_j=1^m fracn_jNw_j w_j \n = 1\nendaligned\n\nOptions\n\nVarious options for the parameters of this function are described in more detail below.\n\nChoices for nbins\n\nYou can specify the number of discrete bins for the histogram. When specifying the number of bins consider the maximum number of graylevels that your image type supports. For example, with an image of type N0f8 there is a maximum of 256 possible graylevels. Hence, if you request more than 256 bins for that type of image you should expect to obtain zero counts for numerous bins.\n\nChoices for minval\n\nYou have the option to specify the lower bound of the interval over which the histogram will be computed.  If minval is not specified then the minimum value present in the image is taken as the lower bound.\n\nChoices for maxval\n\nYou have the option to specify the upper bound of the interval over which the histogram will be computed.  If maxval is not specified then the maximum value present in the image is taken as the upper bound.\n\nChoices for edges\n\nIf you do not designate the number of bins, nor the lower or upper bound of the interval, then you have the option to directly stipulate how the intervals will be divided by specifying a AbstractRange type.\n\nExample\n\nCompute the histogram of a grayscale image.\n\n\nusing TestImages, FileIO, ImageView\n\nimg =  testimage(\"mandril_gray\");\nedges, counts  = build_histogram(img, 256, minval = 0, maxval = 1)\n\nGiven a color image, compute the histogram of the red channel.\n\nimg = testimage(\"mandrill\")\nr = red.(img)\nedges, counts  = build_histogram(r, 256, minval = 0, maxval = 1)\n\nReferences\n\n[1] E. Herrholz, \"Parsimonious Histograms,\" Ph.D. dissertation, Inst. of Math. and Comp. Sci., University of Greifswald, Greifswald, Germany, 2011.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Algorithms-1","page":"Function References","title":"Algorithms","text":"","category":"section"},{"location":"reference/#","page":"Function References","title":"Function References","text":"ImageContrastAdjustment.HistogramAdjustmentAPI.AbstractHistogramAdjustmentAlgorithm","category":"page"},{"location":"reference/#ImageContrastAdjustment.HistogramAdjustmentAPI.AbstractHistogramAdjustmentAlgorithm","page":"Function References","title":"ImageContrastAdjustment.HistogramAdjustmentAPI.AbstractHistogramAdjustmentAlgorithm","text":"AbstractHistogramAdjustmentAlgorithm <: AbstractImageFilter\n\nThe root type for ImageContrastAdjustment package.\n\nAny concrete histogram adjustment algorithm shall subtype it to support adjust_histogram and adjust_histogram! APIs.\n\nExamples\n\nAll histogram adjustment algorithms in ImageContrastAdjustment are called in the following pattern:\n\n# first generate an algorithm instance\nf = LinearStretching()\n\n# then pass the algorithm to `adjust_histogram`\nimg_adjusted = adjust_histogram(img, f)\n\n# or use in-place version `adjust_histogram!`\nimg_adjusted = similar(img)\nadjust_histogram!(img_adjusted, img, f)\n\nSome algorithms also receive additional information as an argument, e.g., nbins of Equalization.\n\n# you can explicit specify the parameters\nf = Equalization(nbins = 32)\n\nFor more examples, please check adjust_histogram, adjust_histogram! and concrete algorithms.\n\n\n\n\n\n","category":"type"},{"location":"reference/#AdaptiveEqualization-1","page":"Function References","title":"AdaptiveEqualization","text":"","category":"section"},{"location":"reference/#","page":"Function References","title":"Function References","text":"AdaptiveEqualization","category":"page"},{"location":"reference/#ImageContrastAdjustment.AdaptiveEqualization","page":"Function References","title":"ImageContrastAdjustment.AdaptiveEqualization","text":"    AdaptiveEqualization <: AbstractHistogramAdjustmentAlgorithm\n    AdaptiveEqualization(; nbins = 256, minval = 0, maxval = 1, rblocks = 8, cblocks = 8, clip = 0.1)\n\n    adjust_histogram([T,] img, f::AdaptiveEqualization)\n    adjust_histogram!([out,] img, f::AdaptiveEqualization)\n\nPerforms Contrast Limited Adaptive Histogram Equalisation (CLAHE) on the input image. It differs from ordinary histogram equalization in the respect that the adaptive method computes several histograms, each corresponding to a distinct section of the image, and uses them to redistribute the lightness values of the image. It is therefore suitable for improving the local contrast and enhancing the definitions of edges in each region of an image.\n\nDetails\n\nHistogram equalisation was initially conceived to  improve the contrast in a single-channel grayscale image. The method transforms the distribution of the intensities in an image so that they are as uniform as possible [1]. The natural justification for uniformity is that the image has better contrast  if the intensity levels of an image span a wide range on the intensity scale. As it turns out, the necessary transformation is a mapping based on the cumulative histogram–-see Equalization for more details.\n\nA natural extension of histogram equalisation is to apply the contrast enhancement locally rather than globally [2]. Conceptually, one can imagine that the process involves partitioning the image into a grid of rectangular regions and applying histogram equalisation based on the local CDF of each contextual region. However, to smooth the transition of the pixels from one contextual region to another,  the mapping of a pixel is not necessarily done soley based on the local CDF of its contextual region. Rather, the mapping of a pixel may be interpolated based on the CDF of its contextual region, and the CDFs of the immediate neighbouring regions.\n\nIn adaptive histogram equalisation the image mathbfG is partitioned into P times Q equisized submatrices,\n\nmathbfG =  beginbmatrix\nmathbfG_11  mathbfG_12  ldots  mathbfG_1C \nmathbfG_21  mathbfG_22  ldots  mathbfG_2C \nvdots  vdots  ldots  vdots \nmathbfG_R1  mathbfG_R2  ldots  mathbfG_RC \nendbmatrix\n\nFor each submatrix mathbfG_rc, one computes a concomitant CDF, which we shall denote by T_rc(G_ij). In the most general case, we will require four CDFs\n\nbeginaligned\nT_1(v)   triangleq  T_rc(G_ij) \nT_2(v)   triangleq  T_(r+1)c(G_ij) \nT_3(v)   triangleq  T_(r+1)(c+1)(G_ij) \nT_4(v)   triangleq  T_r(c+1)(G_ij)\nendaligned\n\nIn order to determine which particular CDFs will be used in the interpolation step, it is useful to (i) introduce the function\n\nPhi(mathbfG_rc) = left(  phi_rc  phi_rcright) triangleq left(rP - fracP2 cQ - fracQ2 right)\n\n(ii) form the sequences  left(phi_11 phi_21 ldots phi_R1 right) and left(phi_11 phi_12 ldots phi_1C right), and (iii) define\n\nbeginaligned\nt   triangleq  fraci - phi_r1phi_(r+1)1 - phi_r1  \nu   triangleq  fracj - phi_1cphi_1(c+1) - phi_1c \nendaligned\n\nCase I (Interior)\n\nFor a  pixel G_ij in the range\n\nP - fracP2 le i le RP - fracP2  quad textand  quad  Q - fracQ2 le j le CQ - fracQ2\n\nvalues of r and c are implicitly defined by the solution to the inequalities\n\nphi_r1 le i  phi_(r+1)1  quad textand  quad  phi_1c le j  phi_1(c+1)\n\nThe bilinearly interpolated transformation that maps an intensity v at location (ij) in the image to an intensity v is given by [3]\n\nv triangleq barT(v)  = (1-t) (1-u)T_1(G_ij) + t(1-u)T_2(G_ij) + tuT_3(G_ij) +(1-t)uT_4(G_ij)\n\nCase II (Vertical Border)\n\nFor a  pixel G_ij in the range\n\nP - fracP2 le i le RP - fracP2  quad textand  quad  1 le j  Q - fracQ2   cup    CQ - fracQ2  j le CQ\n\nr is implicitly defined by the solution to the inequality phi_r1 le i  phi_(r+1)1, while\n\nc = begincases\n   1  textif   quad  1 le j  Q - fracQ2  \n   C  textif  quad   CQ - fracQ2  j le CQ\nendcases\n\nThe linearly interpolated transformation that maps an intensity v at location (ij) in the image to an intensity v is given by\n\nv triangleq barT(v)  = (1-t)T_1(G_ij) + tT_2(G_ij)\n\nCase III (Horizontal Border)\n\nFor a  pixel G_ij in the range\n\n1 le i  P - fracP2  cup    RP - fracP2  i le RP    quad textand  quad  Q - fracQ2 le j le CQ - fracQ2\n\nc is implicitly defined by the solution to the inequality phi_1c le j  phi_1(c+1), while\n\nr = begincases\n   1  textif   quad  1 le i  P - fracP2  \n   R  textif  quad   RP - fracP2  i le RP \nendcases\n\nThe linearly interpolated transformation that maps an intensity v at location (ij) in the image to an intensity v is given by\n\nv triangleq barT(v)  = (1-u)T_1(G_ij) + uT_4(G_ij)\n\nCase IV (Corners)\n\nFor a  pixel G_ij in the range\n\n1 le i  fracP2  cup  RP - fracP2  i le RP   quad textand  quad  1 le j  CQ -  fracQ2  cup    CQ - fracQ2  j le CQ \n\nwe have\n\nr = begincases\n   1  textif   quad  1 le i  P - fracP2  \n   R  textif  quad   RP - fracP2  i le RP\nendcases\n quad textand  quad\nc = begincases\n   1  textif   quad  1 le j  Q - fracQ2  \n   C  textif  quad   CQ - fracQ2  j le CQ\nendcases\n\nThe transformation that maps an intensity v at location (ij) in the image to an intensity v is given by\n\nv triangleq barT(v)  = T_1(G_ij)\n\nLimiting Contrast\n\nAn unfortunate side-effect of contrast enhancement is that it has a tendency to amplify the level of noise in an image, especially when the magnitude of the contrast enhancement is very high. The magnitude of contrast enhancement is associated with the gradient of T(cdot), because the  gradient determines the extent to which consecutive input intensities are stretched across the grey-level spectrum. One can diminish the level of noise amplification by limiting the magnitude of the contrast enhancement, that is, by limiting the magnitude of the gradient.\n\nSince the derivative of T(cdot) is the empirical density hatf_G, the slope of the mapping function at any input intensity is proportional to the height of the histogram  hatf_G at that intensity.  Therefore, limiting the slope of the local mapping function is equivalent to clipping the height of the histogram. A detailed description of the  implementation  details of the clipping process can be found in [2].\n\nOptions\n\nVarious options for the parameters of this function are described in more detail below.\n\nChoices for img\n\nThe function can handle a variety of input types. The returned image depends on the input type.\n\nFor coloured images, the input is converted to YIQ type and the Y channel is equalised. This is the combined with the I and Q channels and the resulting image converted to the same type as the input.\n\nChoices for nbins in AdaptiveEqualization\n\nYou can specify the total number of bins in the histogram of each local region.\n\nChoices for rblocks and cblocks in AdaptiveEqualization\n\nThe rblocks and cblocks specify the number of blocks to divide the input image into in each direction. By default both values are set to eight.\n\nChoices for clip in AdaptiveEqualization\n\nThe clip parameter must be a value between 0 and 1. It defines an implicit threshold at which a histogram is clipped. Counts that exceed the threshold are redistributed as equally as possible so that no bin exceeds the threshold limit. A value of zero means no clipping, whereas a value of one sets the threshold at the smallest feasible bin limit. A bin limit is feasible if all bin counts can be redistributed such that no bin count exceeds the limit. In practice, a clip value of zero corresponds to maximal contrast enhancement, whereas a clip value of one corredponds to minimal contrast enhancement. The default value is 0.1.\n\nChoices for minval and maxval in AdaptiveEqualization\n\nIf minval and maxval are specified then intensities are equalized to the range [minval, maxval]. The default values are 0 and 1.\n\nExample\n\n\nusing TestImages, FileIO, ImageView\n\nimg =  testimage(\"mandril_gray\")\nimgeq = adjust_histogram(img, AdaptiveEqualization(nbins = 256, rblocks = 4, cblocks = 4, clip = 0.2))\n\nimshow(img)\nimshow(imgeq)\n\nReferences\n\nR. C. Gonzalez and R. E. Woods. Digital Image Processing (3rd Edition).  Upper Saddle River, NJ, USA: Prentice-Hall,  2006.\nS. M. Pizer, E. P. Amburn, J. D. Austin, R. Cromartie, A. Geselowitz, T. Greer, B. ter Haar Romeny, J. B. Zimmerman and K. Zuiderveld “Adaptive histogram equalization and its variations,” Computer Vision, Graphics, and Image Processing, vol. 38, no. 1, p. 99, Apr. 1987. 10.1016/S0734-189X(87)80186-X\nW. H. Press, S. A. Teukolsky, W. T. Vetterling, and B. P. Flannery.  Numerical Recipes: The Art of Scientific Computing (3rd Edition). New York, NY, USA: Cambridge University Press, 2007.\n\n\n\n\n\n","category":"type"},{"location":"reference/#ContrastStretching-1","page":"Function References","title":"ContrastStretching","text":"","category":"section"},{"location":"reference/#","page":"Function References","title":"Function References","text":"ContrastStretching","category":"page"},{"location":"reference/#ImageContrastAdjustment.ContrastStretching","page":"Function References","title":"ImageContrastAdjustment.ContrastStretching","text":"    ContrastStretching <: AbstractHistogramAdjustmentAlgorithm\n    ContrastStretching(; t = 0.5,  slope = 1.0)\n\n    adjust_histogram([T,] img, f::ContrastStretching)\n    adjust_histogram!([out,] img, f::ContrastStretching)\n\nReturns an image where intensities below t are compressed into a narrower range of dark intensities, and values above t are compressed into a narrower band of light intensities.\n\nDetails\n\nContrast stretching is a transformation that  enhances or reduces (for slope > 1 or < 1, respectively) the contrast near saturation (0 and 1). It is given by the relation\n\nf(x) = frac11 + left(fractx right)^s  s in mathbbR\n\nwhere s represents the slope argument.\n\nOptions\n\nVarious options for the parameters of the adjust_histogram and ContrastStretching type are described in more detail below.\n\nChoices for img\n\nThe function can handle a variety of input types. The returned image depends on the input type.\n\nFor colored images, the input is converted to the YIQ  type and the intensities of the Y channel are stretched to the specified range. The modified Y channel is then combined with the I and Q channels and the resulting image converted to the same type as the input.\n\nChoice for t\n\nThe value of t needs to be in the unit interval. If left unspecified a default value of 0.5 is utilized.\n\nChoice for slope\n\nThe value of slope can be any real number. If left unspecified a default value of 1.0 is utilized.\n\nExample\n\nusing ImageContrastAdjustment, ImageView, TestImages\n\nimg = testimage(\"mandril_gray\")\nret = adjust_histogram(img, ContrastStretching(t = 0.6, slope = 3))\n\n\nReferences\n\nGonzalez, R. C., Woods, R. E., & Eddins, S. L. (2004). Digital image processing using MATLAB (Vol. 624). Upper Saddle River, New Jersey: Pearson-Prentice-Hall.\n\n\n\n\n\n","category":"type"},{"location":"reference/#Equalization-1","page":"Function References","title":"Equalization","text":"","category":"section"},{"location":"reference/#","page":"Function References","title":"Function References","text":"Equalization","category":"page"},{"location":"reference/#ImageContrastAdjustment.Equalization","page":"Function References","title":"ImageContrastAdjustment.Equalization","text":"    Equalization <: AbstractHistogramAdjustmentAlgorithm\n    Equalization(; nbins = 256, minval = 0, maxval = 1)\n\n    adjust_histogram([T,] img, f::Equalization)\n    adjust_histogram!([out,] img, f::Equalization)\n\nReturns a histogram equalized image with a granularity of nbins number of bins.\n\nDetails\n\nHistogram equalization was initially conceived to  improve the contrast in a single-channel grayscale image. The method transforms the distribution of the intensities in an image so that they are as uniform as possible [1]. The natural justification for uniformity is that the image has better contrast  if the intensity levels of an image span a wide range on the intensity scale. As it turns out, the necessary transformation is a mapping based on the cumulative histogram.\n\nOne can consider an L-bit single-channel I times J image with gray values in the set 01ldotsL-1 , as a collection of independent and identically distributed random variables. Specifically, let the sample space Omega be the set of all IJ-tuples omega =(omega_11omega_12ldotsomega_1Jomega_21omega_22ldotsomega_2Jomega_I1omega_I2ldotsomega_IJ), where each omega_ij in 01ldots L-1 . Furthermore, impose a probability measure on Omega such that the functions Omega ni omega to omega_ij in 01ldotsL-1 are independent and identically distributed.\n\nOne can then regard an image as a matrix of random variables mathbfG = G_ij(omega), where each function G_ij Omega to mathbbR is defined by\n\nG_ij(omega) = fracomega_ijL-1\n\nand each G_ij is distributed according to some unknown density f_G. While f_G is unknown, one can approximate it with a normalized histogram of gray levels,\n\nhatf_G(v)= fracn_vIJ\n\nwhere\n\nn_v = left  left(ij)   G_ij(omega)  = v right  right \n\nrepresents the number of times a gray level with intensity v occurs in mathbfG. To transform the distribution of the intensities so that they are as uniform as possible one needs to find a mapping T(cdot) such that T(G_ij) thicksim U. The required mapping turns out to be the cumulative distribution function (CDF) of the empirical density hatf_G,\n\n T(G_ij) = int_0^G_ijhatf_G(w)mathrmd w\n\nOptions\n\nVarious options for the parameters of the adjust_histogram function and Equalization type are described in more detail below.\n\nChoices for img\n\nThe adjust_histogram function can handle a variety of input types.  By default type of the returned image matches the input type.\n\nFor colored images, the input is converted to YIQ type and the Y channel is equalized. This is the combined with the I and Q channels and the resulting image converted to the same type as the input.\n\nChoices for nbins in Equalization\n\nYou can specify the total number of bins in the histogram.\n\nChoices for minval and maxval in Equalization\n\nIf minval and maxval are specified then intensities are equalized to the range [minval, maxval]. The default values are 0 and 1.\n\nExample\n\n\nusing TestImages, FileIO, ImageView\n\nimg =  testimage(\"mandril_gray\")\nimgeq = adjust_histogram(img, Equalization(nbins = 256, minval = 0, maxval = 1))\n\nimshow(img)\nimshow(imgeq)\n\nReferences\n\nR. C. Gonzalez and R. E. Woods. Digital Image Processing (3rd Edition).  Upper Saddle River, NJ, USA: Prentice-Hall,  2006.\n\n\n\n\n\n","category":"type"},{"location":"reference/#LinearStretching-1","page":"Function References","title":"LinearStretching","text":"","category":"section"},{"location":"reference/#","page":"Function References","title":"Function References","text":"LinearStretching","category":"page"},{"location":"reference/#ImageContrastAdjustment.LinearStretching","page":"Function References","title":"ImageContrastAdjustment.LinearStretching","text":"    LinearStretching <: AbstractHistogramAdjustmentAlgorithm\n    LinearStretching(; [src_minval], [src_maxval],\n                       dst_minval=0, dst_maxval=1,\n                       no_clamp=false)\n\n    LinearStretching((src_minval, src_maxval) => (dst_minval, dst_maxval))\n    LinearStretching((src_minval, src_maxval) => nothing)\n    LinearStretching(nothing => (dst_minval, dst_maxval))\n\n    adjust_histogram([T,] img, f::LinearStretching)\n    adjust_histogram!([out,] img, f::LinearStretching)\n\nReturns an image where the range of the intensities spans the interval [dst_minval, dst_maxval].\n\nDetails\n\nLinear stretching (also called normalization) is a contrast enhancing transformation that is used to modify the dynamic range of the image. In particular, suppose that the input image has gray values in the range [A,B] and one wishes to change the dynamic range to [a,b] using a linear mapping, then the necessary transformation is given by the relation\n\nf(x) = (x-A) fracb-aB-A + a\n\nOptions\n\nVarious options for the parameters of the adjust_histogram and LinearStretching type  are described in more detail below.\n\nChoices for img\n\nThe function can handle a variety of input types. The returned image depends on the input type.\n\nFor colored images, the input is converted to the YIQ  type and the intensities of the Y channel are stretched to the specified range. The modified Y channel is then combined with the I and Q channels and the resulting image converted to the same type as the input.\n\nChoices for dst_minval and dst_maxval\n\nIf destination value range dst_minval and dst_maxval are specified then intensities are mapped to the range [dst_minval, dst_maxval]. The default values are 0 and 1.\n\nChoices for src_minval and src_maxval\n\nThe source value range src_minval and src_maxval specifies the intensity range of input image. By default, the values are extrema(img) (finite). If custom values are provided, the output intensity value will be clamped to range [dst_minval, dst_maxval] if it exceeds that.\n\nno_clamp\n\nSetting no_clamp=true to disable the automatic clamp even if the output intensity value exceeds the range [dst_minval, dst_maxval]. Note that a clamp is still applied for types that has limited value range, for example, if the input eltype is N0f8, then the output will be clamped to [0.0N0f8, 1.0N0f8] even if no_clamp==true.\n\nExample\n\nusing ImageContrastAdjustment, TestImages\n\nimg = testimage(\"mandril_gray\")\n# Stretches the contrast in `img` so that it spans the unit interval.\nimgo = adjust_histogram(img, LinearStretching(dst_minval = 0, dst_maxval = 1))\n\nFor convenience, Constructing a LinearStretching object using Pair is also supported\n\n# these two constructors are equivalent\nLinearStretching(src_minval=0.1, src_maxval=0.9, dst_minval=0.05, dst_maxval=0.95)\nLinearStretching((0.1, 0.9) => (0.05, 0.95))\n\n# replace the part with `nothing` to use default values, e.g.,\n# specify only destination value range\nLinearStretching(nothing => (0.05, 0.95))\n# specify only source value range and use default destination value range, i.e., (0, 1)\nLinearStretching((0.1, 0.9) => nothing)\n\nReferences\n\nW. Burger and M. J. Burge. Digital Image Processing. Texts in Computer Science, 2016. doi:10.1007/978-1-4471-6684-9\n\n\n\n\n\n","category":"type"},{"location":"reference/#Matching-1","page":"Function References","title":"Matching","text":"","category":"section"},{"location":"reference/#","page":"Function References","title":"Function References","text":"Matching","category":"page"},{"location":"reference/#ImageContrastAdjustment.Matching","page":"Function References","title":"ImageContrastAdjustment.Matching","text":"    Matching <: AbstractHistogramAdjustmentAlgorithm\n    Matching(targetimg; nbins = 256, edges = nothing)\n\n    adjust_histogram([T,] img, f::Matching)\n    adjust_histogram!([out,] img, f::Matching)\n\nReturns a histogram matched image with a granularity of nbins number of bins. The first argument img is the image to be matched, whereas the argument targetimg in Matching() is the image having the desired histogram to be matched to.\n\nDetails\n\nThe purpose of histogram matching is to transform the intensities in a source image so that the intensities distribute according to the histogram of a specified target image. If one interprets histograms as piecewise-constant models of probability density functions (see build_histogram), then the histogram matching task can be modelled as the problem of transforming one probability distribution into another [1]. It turns out that the solution to this transformation problem involves the cumulative and inverse cumulative distribution functions of the source and target probability density functions.\n\nIn particular, let the random variables x thicksim p_x and z thicksim p_z  represent an intensity in the source and target image respectively, and let\n\n S(x) = int_0^xp_x(w)mathrmd w quad textand quad\n T(z) = int_0^zp_z(w)mathrmd w\n\nrepresent their concomitant cumulative distribution functions. Then the sought-after mapping Q(cdot) such that Q(x) thicksim p_z is given by\n\nQ(x) =  T^-1left( S(x) right)\n\nwhere T^-1(y) = operatornamemin  x in mathbbR  y leq T(x)  is the inverse cumulative distribution function of T(x).\n\nThe mapping suggests that one can conceptualize histogram matching as performing histogram equalization on the source and target image and relating the two equalized histograms. Refer to adjust_histogram for more details on histogram equalization.\n\nOptions\n\nVarious options for the parameters of the adjust_histogram function and Matching type are described in more detail below.\n\nChoices for img and targetimg\n\nThe adjust_histogram(img, Matching()) function can handle a variety of input types. The type of the returned image matches the input type.\n\nFor colored images, the inputs are converted to YIQ  type and the distributions of the Y channels are matched. The modified Y channel is then combined with the I and Q channels and the resulting image converted to the same type as the input.\n\nChoices for nbins\n\nYou can specify the total number of bins in the histogram. If you do not specify the number of bins then a default value of 256 bins is utilized.\n\nChoices for edges\n\nIf you do not designate the number of bins, then you have the option to directly stipulate how the intervals will be divided by specifying a AbstractRange type.\n\nExample\n\nusing Images, TestImages, ImageView\n\nimg_source = testimage(\"mandril_gray\")\nimg_target = adjust_histogram(img_source, GammaCorrection(gamma = 0.5))\nimg_transformed = adjust_histogram(img_source, Matching(targetimg = img_target))\n#=\n    A visual inspection confirms that img_transformed resembles img_target\n    much more closely than img_source.\n=#\nimshow(img_source)\nimshow(img_target)\nimshow(img_transformed)\n\nReferences\n\nW. Burger and M. J. Burge. Digital Image Processing. Texts in Computer Science, 2016. doi:10.1007/978-1-4471-6684-9\n\n\n\n\n\n","category":"type"},{"location":"reference/#MidwayEqualization-1","page":"Function References","title":"MidwayEqualization","text":"","category":"section"},{"location":"reference/#","page":"Function References","title":"Function References","text":"MidwayEqualization","category":"page"},{"location":"reference/#ImageContrastAdjustment.MidwayEqualization","page":"Function References","title":"ImageContrastAdjustment.MidwayEqualization","text":"    MidwayEqualization <: AbstractHistogramAdjustmentAlgorithm\n    MidwayEqualization(; nbins = 256, minval = 0, maxval = 1)\n\n    adjust_histogram([T,] img_sequence, f::MidwayEqualization(nbins = 256, edges = nothing))\n    adjust_histogram!([out_sequence,] img_sequence, f::MidwayEqualization(nbins = 256, edges = nothing))\n\nGives a pair of images the same histogram whilst maintaining as much as possible their previous grey level dynamics.\n\nDetails\n\nThe purpose of midway histogram equalization is to transform the intensities in a pair of images so that the intensities distribute according to a common \"midway\" distribution. The histogram representing the common distribution is chosen so that the original  gray level dynamics of the images are preserved as much as possible. If one interprets histograms as piecewise-constant models of probability density functions (see build_histogram), then the midway histogram equalization task can be modeled as the problem of transforming one probability distribution into another (see adjust_histogram). It turns out that the solution to this transformation problem involves the cumulative and inverse cumulative distribution functions of the source and \"midway\" probability density functions. In particular, let the random variables X_i thicksim p_x_i  (i = 12), and Z thicksim p_z  represent an intensity in the first, second and \"midway\" image respectively, and let\n\n S_X_i(x) = int_0^xp_x_i(w)mathrmd w  quad textand quad\n T_Z(x) = frac2frac1S_X_1(x) + frac1S_X_2(x)\n\nrepresent the cumulative distribution functions of the two input images, and their harmonic mean, respectively. Then the sought-after mapping Q_X_i(cdot) (i = 12) such that Q_X_i(x) thicksim p_z is given by\n\nQ_X_i(x) =  T_Z^-1left( S_X_i(x) right)\n\nwhere T_Z^-1(y) = operatornamemin  x in mathbbR  y leq T_Z(x)  is the inverse cumulative distribution function of T_Z(x).\n\nOptions\n\nVarious options for the parameters of the adjust_histogram function and MidwayEqualization types are described in more detail below.\n\nChoices for img_sequence\n\nThe function adjust_histogram expects a length-2 Vector of images (the pair of images) and returns a length-2 Vector of modified images.  The  function can handle a variety of input types. The type of the returned image matches the input type.\n\nFor colored images, the inputs are converted to YIQ  type and the distributions of the Y channels are transformed according to a \"midway\" distribution. The modified Y channel is then combined with the I and Q channels and the resulting image converted to the same type as the input.\n\nChoices for nbins\n\nYou can specify the total number of bins in the histogram. If you do not specify the number of bins then a default value of 256 bins is utilized.\n\nChoices for edges\n\nIf you do not designate the number of bins, then you have the option to directly stipulate how the intervals will be divided by specifying a AbstractRange type.\n\nExample\n\nusing Images, TestImages, ImageView, ImageContrastAdjustment\n\nimg = testimage(\"mandril_gray\")\n\n# The same image but with different intensitiy distributions\nimg1 = adjust_histogram(img, GammaCorrection(gamma = 2))\nimg2 = adjust_histogram(img, GammaCorrection(gamma = 1.2))\n\n# Midway histogram equalization will transform these two images so that their\n# intensity distributions are almost identical.\nimg_sequence = adjust_histogram([img1, img2], MidwayEqualization(nbins = 256))\nimg1o = first(img_sequence)\nimg2o = last(img_sequence)\n\nReferences\n\nT. Guillemot and J. Delon, “Implementation of the Midway Image Equalization,” Image Processing On Line, vol. 5, pp. 114–129, Jun. 2016. doi:10.5201/ipol.2016.140\n\n\n\n\n\n","category":"type"},{"location":"#ImageContrastAdjustment.jl-Documentation-1","page":"ImageContrastAdjustment.jl Documentation","title":"ImageContrastAdjustment.jl Documentation","text":"","category":"section"},{"location":"#","page":"ImageContrastAdjustment.jl Documentation","title":"ImageContrastAdjustment.jl Documentation","text":"A Julia package for enhancing and manipulating image contrast.","category":"page"},{"location":"#","page":"ImageContrastAdjustment.jl Documentation","title":"ImageContrastAdjustment.jl Documentation","text":"Depth = 3","category":"page"},{"location":"#Getting-started-1","page":"ImageContrastAdjustment.jl Documentation","title":"Getting started","text":"","category":"section"},{"location":"#","page":"ImageContrastAdjustment.jl Documentation","title":"ImageContrastAdjustment.jl Documentation","text":"This package is part of a wider Julia-based image processing ecosystem. If you are starting out, then you may benefit from reading about some fundamental conventions that the ecosystem utilizes that are markedly different from how images are typically represented in OpenCV, MATLAB, ImageJ or Python.","category":"page"},{"location":"#","page":"ImageContrastAdjustment.jl Documentation","title":"ImageContrastAdjustment.jl Documentation","text":"The usage examples in the ImageContrastAdjustment.jl package assume that you have already installed some key packages. Notably, the examples assume that you are able to load and display an image. Loading an image is facilitated through the FileIO.jl package, which uses QuartzImageIO.jl if you are on MacOS, and ImageMagick.jl otherwise. Depending on your particular system configuration, you might encounter problems installing the image loading packages, in which case you can refer to the troubleshooting guide.","category":"page"},{"location":"#","page":"ImageContrastAdjustment.jl Documentation","title":"ImageContrastAdjustment.jl Documentation","text":"Image display is typically handled by the ImageView.jl package.  Alternatives include the various plotting packages, including Makie.jl. There is also the ImageShow.jl package which facilitates displaying images in Jupyter notebooks via IJulia.jl. Finally, one can also obtain a useful preview of an image in the REPL using the ImageInTerminal.jl package. However, this package assumes that the terminal uses a monospace font, and tends not to produce adequate results in a Windows environment.","category":"page"},{"location":"#","page":"ImageContrastAdjustment.jl Documentation","title":"ImageContrastAdjustment.jl Documentation","text":"Another package that is used to illustrate the functionality in ImageContrastAdjustment.jl is the TestImages.jl which serves as a repository of many standard image processing test images.","category":"page"},{"location":"#Basic-usage-1","page":"ImageContrastAdjustment.jl Documentation","title":"Basic usage","text":"","category":"section"},{"location":"#","page":"ImageContrastAdjustment.jl Documentation","title":"ImageContrastAdjustment.jl Documentation","text":"Each contrast manipulation algorithm in ImageContrastAdjustment.jl is an AbstractHistogramAdjustmentAlgorithm.","category":"page"},{"location":"#","page":"ImageContrastAdjustment.jl Documentation","title":"ImageContrastAdjustment.jl Documentation","text":"Suppose one wants to enhance the contrast an image. This can be achieved by simply choosing an appropriate algorithm and calling adjust_histogram or adjust_histogram! in the image. The contrast will be automatically enhanced.","category":"page"},{"location":"#","page":"ImageContrastAdjustment.jl Documentation","title":"ImageContrastAdjustment.jl Documentation","text":"Let's see a simple demo:","category":"page"},{"location":"#","page":"ImageContrastAdjustment.jl Documentation","title":"ImageContrastAdjustment.jl Documentation","text":"using TestImages, ImageContrastAdjustment\nusing FileIO # hide\nimg = testimage(\"cameraman\")\nalg = Equalization(nbins = 256)\nimg_adjusted = adjust_histogram(img, alg)\nsave(\"images/demo.jpg\", hcat(img, img_adjusted)) # hide","category":"page"},{"location":"#","page":"ImageContrastAdjustment.jl Documentation","title":"ImageContrastAdjustment.jl Documentation","text":"<img src=\"images/demo.jpg\" width=\"400px\" alt=\"demo image\" />","category":"page"},{"location":"#","page":"ImageContrastAdjustment.jl Documentation","title":"ImageContrastAdjustment.jl Documentation","text":"This usage reads as \"adjust_histogram of the image img with algorithm alg\"","category":"page"},{"location":"#","page":"ImageContrastAdjustment.jl Documentation","title":"ImageContrastAdjustment.jl Documentation","text":"For more advanced usage, please check function reference page.","category":"page"},{"location":"#Examples-1","page":"ImageContrastAdjustment.jl Documentation","title":"Examples","text":"","category":"section"},{"location":"#","page":"ImageContrastAdjustment.jl Documentation","title":"ImageContrastAdjustment.jl Documentation","text":"Below are some examples of contrast adjustment operations that this package facilitates.","category":"page"},{"location":"#","page":"ImageContrastAdjustment.jl Documentation","title":"ImageContrastAdjustment.jl Documentation","text":"<table width=\"500\" border=\"0\" cellpadding=\"5\">\n\n<tr>\n\n<td align=\"center\" valign=\"center\">\n<img src=\"images/contrast_stretching.gif\" width=\"100px\" alt=\"Contrast Stretching\" />\n<br />\nContrast Stretching\n</td>\n\n<td align=\"center\" valign=\"center\">\n<img src=\"images/contrast_stretching_col.gif\" width=\"100px\" alt=\"Contrast Stretching\" />\n<br />\nContrast Stretching\n</td>\n\n</tr>\n\n<tr>\n\n<td align=\"center\" valign=\"center\">\n<img src=\"images/linear_stretching.gif\" width=\"100px\" alt=\"Linear Stretching (Normalization)\" />\n<br />\nLinear Stretching/Normalization\n</td>\n\n<td align=\"center\" valign=\"center\">\n<img src=\"images/linear_stretching_col.gif\" width=\"100px\" alt=\"Linear Stretching (Normalization)\" />\n<br />\nLinear Stretching/Normalization\n</td>\n\n</tr>\n\n<tr>\n\n<td align=\"center\" valign=\"center\">\n<img src=\"images/gamma_correction.gif\" width=\"100px\" alt=\"Gamma Correction\" />\n<br />\nGamma Correction\n</td>\n\n<td align=\"center\" valign=\"center\">\n<img src=\"images/gamma_correction_col.gif\" width=\"100px\" alt=\"Gamma Correction\" />\n<br />\nGamma Correction\n</td>\n\n</tr>\n\n<tr>\n\n<td align=\"center\" valign=\"center\">\n<img src=\"images/equalization.gif\" width=\"100px\" alt=\"Histogram Equalization\" />\n<br />\nHistogram Equalization\n</td>\n\n<td align=\"center\" valign=\"center\">\n<img src=\"images/equalization_col.gif\" width=\"100px\" alt=\"Histogram Equalization\" />\n<br />\nHistogram Equalization\n</td>\n\n</tr>\n\n<tr>\n\n<td align=\"center\" valign=\"center\">\n<img src=\"images/adaptive_equalization.gif\" width=\"100px\" alt=\"Contrast Limited Adaptive Histogram Equalization\" />\n<br />\nContrast Limited Adaptive Histogram Equalization\n</td>\n\n<td align=\"center\" valign=\"center\">\n<img src=\"images/adaptive_equalization_col.gif\" width=\"100px\" alt=\"Contrast Limited Adaptive Histogram Equalization\" />\n<br />\nContrast Limited Adaptive Histogram Equalization\n</td>\n\n</tr>\n\n<tr>\n\n<td align=\"center\" valign=\"center\">\n<img src=\"images/midway_equalization.gif\" width=\"100px\" alt=\"Midway Histogram Equalization\" />\n<br />\nMidway Histogram Equalization\n</td>\n\n<td align=\"center\" valign=\"center\">\n<img src=\"images/midway_equalization_col.gif\" width=\"100px\" alt=\"Midway Histogram Equalization\" />\n<br />\nMidway Histogram Equalization\n</td>\n\n</tr>\n\n<tr>\n\n<td align=\"center\" valign=\"center\">\n<img src=\"images/matching.gif\" width=\"100px\" alt=\"Histogram Matching\" />\n<br />\nHistogram Matching\n</td>\n\n<td align=\"center\" valign=\"center\">\n<img src=\"images/matching_col.gif\" width=\"100px\" alt=\"Histogram Matching\" />\n<br />\nHistogram Matching\n</td>\n\n</tr>\n\n</table>","category":"page"}]
}
