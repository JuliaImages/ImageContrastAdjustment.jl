var documenterSearchIndex = {"docs":
[{"location":"reference/#function_reference-1","page":"Function References","title":"Function References","text":"","category":"section"},{"location":"reference/#","page":"Function References","title":"Function References","text":"Pages = [\"reference.md\"]\nDepth = 3","category":"page"},{"location":"reference/#General-function-1","page":"Function References","title":"General function","text":"","category":"section"},{"location":"reference/#","page":"Function References","title":"Function References","text":"adjust_histogram\nadjust_histogram!\nbuild_histogram","category":"page"},{"location":"reference/#ImageContrastAdjustment.HistogramAdjustmentAPI.adjust_histogram","page":"Function References","title":"ImageContrastAdjustment.HistogramAdjustmentAPI.adjust_histogram","text":"adjust_histogram([T::Type,] img, f::AbstractHistogramAdjustmentAlgorithm, args...; kwargs...)\n\nAdjust histogram of img using algorithm f.\n\nOutput\n\nThe return image img_adjusted is an Array{T}.\n\nIf T is not specified, then it's inferred.\n\nExamples\n\nJust simply pass the input image and algorithm to adjust_histogram\n\nimg_adjusted = adjust_histogram(img, f)\n\nThis reads as \"adjust_histogram of image img using algorithm f\".\n\nYou can also explicitly specify the return type:\n\nimg_adjusted_float32 = adjust_histogram(Gray{Float32}, img, f)\n\nSee also adjust_histogram! for in-place histogram adjustment.\n\n\n\n\n\n","category":"function"},{"location":"reference/#ImageContrastAdjustment.HistogramAdjustmentAPI.adjust_histogram!","page":"Function References","title":"ImageContrastAdjustment.HistogramAdjustmentAPI.adjust_histogram!","text":"adjust_histogram!([out,] img, f::AbstractHistogramAdjustmentAlgorithm, args...; kwargs...)\n\nAdjust histogram of img using algorithm f.\n\nOutput\n\nIf out is specified, it will be changed in place. Otherwise img will be changed in place.\n\nExamples\n\nJust simply pass an algorithm to adjust_histogram!:\n\nimg_adjusted = similar(img)\nadjust_histogram!(img_adjusted, img, f)\n\nFor cases you just want to change img in place, you don't necessarily need to manually allocate img_adjusted; just use the convenient method:\n\nadjust_histogram!(img, f)\n\nSee also: adjust_histogram\n\n\n\n\n\n","category":"function"},{"location":"reference/#ImageContrastAdjustment.build_histogram","page":"Function References","title":"ImageContrastAdjustment.build_histogram","text":"edges, count = build_histogram(img, nbins)\nedges, count = build_histogram(img, nbins; minval, maxval)\nedges, count = build_histogram(img, edges)\n\nGenerates a histogram for the image over nbins spread between [minval, maxval]. Color images are automatically converted to grayscale.\n\nOutput\n\nReturns edges which is a AbstractRange type that specifies how the  interval [minval, maxval] is divided into bins, and an array count which records the concomitant bin frequencies. In particular, count has the following properties:\n\ncount[0] is the number satisfying x < edges[1]\ncount[i] is the number of values x that satisfy edges[i] <= x < edges[i+1]\ncount[end] is the number satisfying x >= edges[end].\nlength(count) == length(edges)+1.\n\nDetails\n\nOne can consider a histogram as a piecewise-constant model of a probability density function f [1]. Suppose that f has support on some interval I = ab.  Let m be an integer and a = a_1  a_2  ldots  a_m  a_m+1 = b a sequence of real numbers. Construct a sequence of intervals\n\nI_1 = a_1a_2 I_2 = (a_2 a_3 ldots I_m = (a_ma_m+1\n\nwhich partition I into subsets I_j (j = 1 ldots m) on which f is constant. These subsets satisfy I_i cap I_j = emptyset forall i neq j, and are commonly referred to as bins. Together they encompass the entire range of data values such that sum_j I_j  =  I . Each bin has width w_j = I_j = a_j+1 - a_j and height h_j which is the constant probability density over the region of the bin. Integrating the constant probability density over the width of the bin w_j yields a probability mass of pi_j = h_j w_j for the bin.\n\nFor a sample x_1 x_2 ldots x_N, let\n\nn_j = sum_n = 1^Nmathbf1_(I_j)(x_n)\nquad textwhere quad\nmathbf1_(I_j)(x) =\nbegincases\n 1  textif  x in I_j\n 0  textotherwise\nendcases\n\nrepresent the number of samples falling into the interval I_j. An estimate for the probability mass of the jth bin is given by the relative frequency hatpi = fracn_jN, and the histogram estimator of the probability density function is defined as\n\nbeginaligned\nhatf_n(x)   = sum_j = 1^mfracn_jNw_j mathbf1_(I_j)(x) \n = sum_j = 1^mfrachatpi_jw_j mathbf1_(I_j)(x) \n = sum_j = 1^mhath_j mathbf1_(I_j)(x)\nendaligned\n\nThe function hatf_n(x) is a genuine density estimator because hatf_n(x)  ge 0 and\n\nbeginaligned\nint_-infty^inftyhatf_n(x) operatornamedx  = sum_j=1^m fracn_jNw_j w_j \n = 1\nendaligned\n\nOptions\n\nVarious options for the parameters of this function are described in more detail below.\n\nChoices for nbins\n\nYou can specify the number of discrete bins for the histogram. When specifying the number of bins consider the maximum number of graylevels that your image type supports. For example, with an image of type N0f8 there is a maximum of 256 possible graylevels. Hence, if you request more than 256 bins for that type of image you should expect to obtain zero counts for numerous bins.\n\nChoices for minval\n\nYou have the option to specify the lower bound of the interval over which the histogram will be computed.  If minval is not specified then the minimum value present in the image is taken as the lower bound.\n\nChoices for maxval\n\nYou have the option to specify the upper bound of the interval over which the histogram will be computed.  If maxval is not specified then the maximum value present in the image is taken as the upper bound.\n\nChoices for edges\n\nIf you do not designate the number of bins, nor the lower or upper bound of the interval, then you have the option to directly stipulate how the intervals will be divided by specifying a AbstractRange type.\n\nExample\n\nCompute the histogram of a grayscale image.\n\n\nusing TestImages, FileIO, ImageView\n\nimg =  testimage(\"mandril_gray\");\nedges, counts  = build_histogram(img, 256, minval = 0, maxval = 1)\n\nGiven a color image, compute the histogram of the red channel.\n\nimg = testimage(\"mandrill\")\nr = red.(img)\nedges, counts  = build_histogram(r, 256, minval = 0, maxval = 1)\n\nReferences\n\n[1] E. Herrholz, \"Parsimonious Histograms,\" Ph.D. dissertation, Inst. of Math. and Comp. Sci., University of Greifswald, Greifswald, Germany, 2011.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Algorithms-1","page":"Function References","title":"Algorithms","text":"","category":"section"},{"location":"reference/#","page":"Function References","title":"Function References","text":"ImageContrastAdjustment.HistogramAdjustmentAPI.AbstractHistogramAdjustmentAlgorithm","category":"page"},{"location":"reference/#ImageContrastAdjustment.HistogramAdjustmentAPI.AbstractHistogramAdjustmentAlgorithm","page":"Function References","title":"ImageContrastAdjustment.HistogramAdjustmentAPI.AbstractHistogramAdjustmentAlgorithm","text":"AbstractHistogramAdjustmentAlgorithm <: AbstractImageFilter\n\nThe root type for ImageContrastAdjustment package.\n\nAny concrete histogram adjustment algorithm shall subtype it to support adjust_histogram and adjust_histogram! APIs.\n\nExamples\n\nAll histogram adjustment algorithms in ImageContrastAdjustment are called in the following pattern:\n\n# first generate an algorithm instance\nf = LinearStretching()\n\n# then pass the algorithm to `adjust_histogram`\nimg_adjusted = adjust_histogram(img, f)\n\n# or use in-place version `adjust_histogram!`\nimg_adjusted = similar(img)\nadjust_histogram!(img_adjusted, img, f)\n\nSome algorithms also receive additional information as an argument, e.g., nbins of Equalization.\n\n# you can explicit specify the parameters\nf = Equalization(nbins = 32)\n\nFor more examples, please check adjust_histogram, adjust_histogram! and concrete algorithms.\n\n\n\n\n\n","category":"type"},{"location":"reference/#ContrastStretching-1","page":"Function References","title":"ContrastStretching","text":"","category":"section"},{"location":"reference/#","page":"Function References","title":"Function References","text":"ContrastStretching","category":"page"},{"location":"reference/#ImageContrastAdjustment.ContrastStretching","page":"Function References","title":"ImageContrastAdjustment.ContrastStretching","text":"    ContrastStretching <: AbstractHistogramAdjustmentAlgorithm\n    ContrastStretching(; t = 0.5,  slope = 1.0)\n\n    adjust_histogram([T,] img, f::ContrastStretching)\n    adjust_histogram!([out,] img, f::ContrastStretching)\n\nReturns an image where intensities below t are compressed into a narrower range of dark intensities, and values above t are compressed into a narrower band of light intensities.\n\nDetails\n\nContrast stretching is a transformation that  enhances or reduces (for slope > 1 or < 1, respectively) the contrast near saturation (0 and 1). It is given by the relation\n\nf(x) = frac11 + left(fractx right)^s  s in mathbbR\n\nwhere s represents the slope argument.\n\nOptions\n\nVarious options for the parameters of the adjust_histogram and ContrastStretching type are described in more detail below.\n\nChoices for img\n\nThe function can handle a variety of input types. The returned image depends on the input type.\n\nFor colored images, the input is converted to the YIQ  type and the intensities of the Y channel are stretched to the specified range. The modified Y channel is then combined with the I and Q channels and the resulting image converted to the same type as the input.\n\nChoice for t\n\nThe value of t needs to be in the unit interval. If left unspecified a default value of 0.5 is utilized.\n\nChoice for slope\n\nThe value of slope can be any real number. If left unspecified a default value of 1.0 is utilized.\n\nExample\n\nusing ImageContrastAdjustment, ImageView, TestImages\n\nimg = testimage(\"mandril_gray\")\nret = adjust_histogram(img, ContrastStretching(t = 0.6, slope = 3))\n\n\nReferences\n\nGonzalez, R. C., Woods, R. E., & Eddins, S. L. (2004). Digital image processing using MATLAB (Vol. 624). Upper Saddle River, New Jersey: Pearson-Prentice-Hall.\n\n\n\n\n\n","category":"type"},{"location":"reference/#Equalization-1","page":"Function References","title":"Equalization","text":"","category":"section"},{"location":"reference/#","page":"Function References","title":"Function References","text":"Equalization","category":"page"},{"location":"reference/#ImageContrastAdjustment.Equalization","page":"Function References","title":"ImageContrastAdjustment.Equalization","text":"    Equalization <: AbstractHistogramAdjustmentAlgorithm\n    Equalization(; nbins = 256, minval = 0, maxval = 1)\n\n    adjust_histogram([T,] img, f::Equalization)\n    adjust_histogram!([out,] img, f::Equalization)\n\nReturns a histogram equalized image with a granularity of nbins number of bins.\n\nDetails\n\nHistogram equalization was initially conceived to  improve the contrast in a single-channel grayscale image. The method transforms the distribution of the intensities in an image so that they are as uniform as possible [1]. The natural justification for uniformity is that the image has better contrast  if the intensity levels of an image span a wide range on the intensity scale. As it turns out, the necessary transformation is a mapping based on the cumulative histogram.\n\nOne can consider an L-bit single-channel I times J image with gray values in the set 01ldotsL-1 , as a collection of independent and identically distributed random variables. Specifically, let the sample space Omega be the set of all IJ-tuples omega =(omega_11omega_12ldotsomega_1Jomega_21omega_22ldotsomega_2Jomega_I1omega_I2ldotsomega_IJ), where each omega_ij in 01ldots L-1 . Furthermore, impose a probability measure on Omega such that the functions Omega ni omega to omega_ij in 01ldotsL-1 are independent and identically distributed.\n\nOne can then regard an image as a matrix of random variables mathbfG = G_ij(omega), where each function G_ij Omega to mathbbR is defined by\n\nG_ij(omega) = fracomega_ijL-1\n\nand each G_ij is distributed according to some unknown density f_G. While f_G is unknown, one can approximate it with a normalized histogram of gray levels,\n\nhatf_G(v)= fracn_vIJ\n\nwhere\n\nn_v = left  left(ij)   G_ij(omega)  = v right  right \n\nrepresents the number of times a gray level with intensity v occurs in mathbfG. To transform the distribution of the intensities so that they are as uniform as possible one needs to find a mapping T(cdot) such that T(G_ij) thicksim U. The required mapping turns out to be the cumulative distribution function (CDF) of the empirical density hatf_G,\n\n T(G_ij) = int_0^G_ijhatf_G(w)mathrmd w\n\nOptions\n\nVarious options for the parameters of the adjust_histogram function and Equalization type are described in more detail below.\n\nChoices for img\n\nThe adjust_histogram function can handle a variety of input types.  By default type of the returned image matches the input type.\n\nFor colored images, the input is converted to YIQ type and the Y channel is equalized. This is the combined with the I and Q channels and the resulting image converted to the same type as the input.\n\nChoices for nbins in Equalization\n\nYou can specify the total number of bins in the histogram.\n\nChoices for minval and maxval in Equalization\n\nIf minval and maxval are specified then intensities are equalized to the range [minval, maxval]. The default values are 0 and 1.\n\nExample\n\n\nusing TestImages, FileIO, ImageView\n\nimg =  testimage(\"mandril_gray\")\nimgeq = adjust_histogram(img, Equalization(nbins = 256, minval = 0, maxval = 1))\n\nimshow(img)\nimshow(imgeq)\n\nReferences\n\nR. C. Gonzalez and R. E. Woods. Digital Image Processing (3rd Edition).  Upper Saddle River, NJ, USA: Prentice-Hall,  2006.\n\n\n\n\n\n","category":"type"},{"location":"reference/#LinearStretching-1","page":"Function References","title":"LinearStretching","text":"","category":"section"},{"location":"reference/#","page":"Function References","title":"Function References","text":"LinearStretching","category":"page"},{"location":"reference/#ImageContrastAdjustment.LinearStretching","page":"Function References","title":"ImageContrastAdjustment.LinearStretching","text":"    LinearStretching <: AbstractHistogramAdjustmentAlgorithm\n    LinearStretching(; minval = 0, maxval = 1)\n\n    adjust_histogram([T,] img, f::LinearStretching)\n    adjust_histogram!([out,] img, f::LinearStretching)\n\nReturns an image where the range of the intensities spans the interval [minval, maxval].\n\nDetails\n\nLinear stretching (also called normalization) is a contrast enhancing transformation that is used to modify the dynamic range of the image. In particular, suppose that the input image has gray values in the range [A,B] and one wishes to change the dynamic range to [a,b] using a linear mapping, then the necessary transformation is given by the relation\n\nf(x) = (x-A) fracb-aB-A + a\n\nOptions\n\nVarious options for the parameters of the adjust_histogram and LinearStretching type  are described in more detail below.\n\nChoices for img\n\nThe function can handle a variety of input types. The returned image depends on the input type.\n\nFor colored images, the input is converted to the YIQ  type and the intensities of the Y channel are stretched to the specified range. The modified Y channel is then combined with the I and Q channels and the resulting image converted to the same type as the input.\n\nChoices for minval and maxval\n\nIf minval and maxval are specified then intensities are mapped to the range [minval, maxval]. The default values are 0 and 1.\n\nExample\n\nusing ImageContrastAdjustment, ImageView, TestImages\n\nimg = testimage(\"mandril_gray\")\nimgo = adjust_histogram(img, LinearStretching(minval = 0, maxval = 1))\n\n\nReferences\n\nW. Burger and M. J. Burge. Digital Image Processing. Texts in Computer Science, 2016. doi:10.1007/978-1-4471-6684-9\n\n\n\n\n\n","category":"type"},{"location":"reference/#Matching-1","page":"Function References","title":"Matching","text":"","category":"section"},{"location":"reference/#","page":"Function References","title":"Function References","text":"Matching","category":"page"},{"location":"reference/#ImageContrastAdjustment.Matching","page":"Function References","title":"ImageContrastAdjustment.Matching","text":"    Matching <: AbstractHistogramAdjustmentAlgorithm\n    Matching(targetimg; nbins = 256, edges = nothing)\n\n    adjust_histogram([T,] img, f::Matching)\n    adjust_histogram!([out,] img, f::Matching)\n\nReturns a histogram matched image with a granularity of nbins number of bins. The first argument img is the image to be matched, whereas the argument targetimg in Matching() is the image having the desired histogram to be matched to.\n\nDetails\n\nThe purpose of histogram matching is to transform the intensities in a source image so that the intensities distribute according to the histogram of a specified target image. If one interprets histograms as piecewise-constant models of probability density functions (see build_histogram), then the histogram matching task can be modelled as the problem of transforming one probability distribution into another [1]. It turns out that the solution to this transformation problem involves the cumulative and inverse cumulative distribution functions of the source and target probability density functions.\n\nIn particular, let the random variables x thicksim p_x and z thicksim p_z  represent an intensity in the source and target image respectively, and let\n\n S(x) = int_0^xp_x(w)mathrmd w quad textand quad\n T(z) = int_0^zp_z(w)mathrmd w\n\nrepresent their concomitant cumulative distribution functions. Then the sought-after mapping Q(cdot) such that Q(x) thicksim p_z is given by\n\nQ(x) =  T^-1left( S(x) right)\n\nwhere T^-1(y) = operatornamemin  x in mathbbR  y leq T(x)  is the inverse cumulative distribution function of T(x).\n\nThe mapping suggests that one can conceptualize histogram matching as performing histogram equalization on the source and target image and relating the two equalized histograms. Refer to adjust_histogram for more details on histogram equalization.\n\nOptions\n\nVarious options for the parameters of the adjust_histogram function and Matching type are described in more detail below.\n\nChoices for img and targetimg\n\nThe adjust_histogram(img, Matching()) function can handle a variety of input types. The type of the returned image matches the input type.\n\nFor colored images, the inputs are converted to YIQ  type and the distributions of the Y channels are matched. The modified Y channel is then combined with the I and Q channels and the resulting image converted to the same type as the input.\n\nChoices for nbins\n\nYou can specify the total number of bins in the histogram. If you do not specify the number of bins then a default value of 256 bins is utilized.\n\nChoices for edges\n\nIf you do not designate the number of bins, then you have the option to directly stipulate how the intervals will be divided by specifying a AbstractRange type.\n\nExample\n\nusing Images, TestImages, ImageView\n\nimg_source = testimage(\"mandril_gray\")\nimg_target = adjust_gamma(img_source, 1/2)\nimg_transformed = adjust_histogram(img_source, Matching(targetimg = img_target))\n#=\n    A visual inspection confirms that img_transformed resembles img_target\n    much more closely than img_source.\n=#\nimshow(img_source)\nimshow(img_target)\nimshow(img_transformed)\n\nReferences\n\nW. Burger and M. J. Burge. Digital Image Processing. Texts in Computer Science, 2016. doi:10.1007/978-1-4471-6684-9\n\n\n\n\n\n","category":"type"},{"location":"reference/#MidwayEqualization-1","page":"Function References","title":"MidwayEqualization","text":"","category":"section"},{"location":"reference/#","page":"Function References","title":"Function References","text":"MidwayEqualization","category":"page"},{"location":"reference/#ImageContrastAdjustment.MidwayEqualization","page":"Function References","title":"ImageContrastAdjustment.MidwayEqualization","text":"    MidwayEqualization <: AbstractHistogramAdjustmentAlgorithm\n    MidwayEqualization(; nbins = 256, minval = 0, maxval = 1)\n\n    adjust_histogram([T,] img_sequence, f::MidwayEqualization(nbins = 256, edges = nothing))\n    adjust_histogram!([out_sequence,] img_sequence, f::MidwayEqualization(nbins = 256, edges = nothing))\n\nGives a pair of images the same histogram whilst maintaining as much as possible their previous grey level dynamics.\n\nDetails\n\nThe purpose of midway histogram equalization is to transform the intensities in a pair of images so that the intensities distribute according to a common \"midway\" distribution. The histogram representing the common distribution is chosen so that the original  gray level dynamics of the images are preserved as much as possible. If one interprets histograms as piecewise-constant models of probability density functions (see build_histogram), then the midway histogram equalization task can be modeled as the problem of transforming one probability distribution into another (see adjust_histogram). It turns out that the solution to this transformation problem involves the cumulative and inverse cumulative distribution functions of the source and \"midway\" probability density functions. In particular, let the random variables X_i thicksim p_x_i  (i = 12), and Z thicksim p_z  represent an intensity in the first, second and \"midway\" image respectively, and let\n\n S_X_i(x) = int_0^xp_x_i(w)mathrmd w  quad textand quad\n T_Z(x) = frac2frac1S_X_1(x) + frac1S_X_2(x)\n\nrepresent the cumulative distribution functions of the two input images, and their harmonic mean, respectively. Then the sought-after mapping Q_X_i(cdot) (i = 12) such that Q_X_i(x) thicksim p_z is given by\n\nQ_X_i(x) =  T_Z^-1left( S_X_i(x) right)\n\nwhere T_Z^-1(y) = operatornamemin  x in mathbbR  y leq T_Z(x)  is the inverse cumulative distribution function of T_Z(x).\n\nOptions\n\nVarious options for the parameters of the adjust_histogram function and MidwayEqualization types are described in more detail below.\n\nChoices for img_sequence\n\nThe function adjust_histogram expects a length-2 Vector of images (the pair of images) and returns a length-2 Vector of modified images.  The  function can handle a variety of input types. The type of the returned image matches the input type.\n\nFor colored images, the inputs are converted to YIQ  type and the distributions of the Y channels are transformed according to a \"midway\" distribution. The modified Y channel is then combined with the I and Q channels and the resulting image converted to the same type as the input.\n\nChoices for nbins\n\nYou can specify the total number of bins in the histogram. If you do not specify the number of bins then a default value of 256 bins is utilized.\n\nChoices for edges\n\nIf you do not designate the number of bins, then you have the option to directly stipulate how the intervals will be divided by specifying a AbstractRange type.\n\nExample\n\nusing Images, TestImages, ImageView, ImageContrastAdjustment\n\nimg = testimage(\"mandril_gray\")\n\n# The same image but with different intensitiy distributions\nimg1 = adjust_histogram(img, GammaCorrection(gamma = 2))\nimg2 = adjust_histogram(img, GammaCorrection(gamma = 1.2))\n\n# Midway histogram equalization will transform these two images so that their\n# intensity distributions are almost identical.\nimg_sequence = adjust_histogram([img1, img2], MidwayEqualization(nbins = 256))\nimg1o = first(img_sequence)\nimg2o = last(img_sequence)\n\nReferences\n\nT. Guillemot and J. Delon, “Implementation of the Midway Image Equalization,” Image Processing On Line, vol. 5, pp. 114–129, Jun. 2016. doi:10.5201/ipol.2016.140\n\n\n\n\n\n","category":"type"},{"location":"#ImageContrastAdjustment.jl-Documentation-1","page":"ImageContrastAdjustment.jl Documentation","title":"ImageContrastAdjustment.jl Documentation","text":"","category":"section"},{"location":"#","page":"ImageContrastAdjustment.jl Documentation","title":"ImageContrastAdjustment.jl Documentation","text":"A Julia package for enhancing and manipulating image contrast.","category":"page"},{"location":"#","page":"ImageContrastAdjustment.jl Documentation","title":"ImageContrastAdjustment.jl Documentation","text":"Depth = 3","category":"page"},{"location":"#Getting-started-1","page":"ImageContrastAdjustment.jl Documentation","title":"Getting started","text":"","category":"section"},{"location":"#","page":"ImageContrastAdjustment.jl Documentation","title":"ImageContrastAdjustment.jl Documentation","text":"This package is part of a wider Julia-based image processing ecosystem. If you are starting out, then you may benefit from reading about some fundamental conventions that the ecosystem utilizes that are markedly different from how images are typically represented in OpenCV, MATLAB, ImageJ or Python.","category":"page"},{"location":"#","page":"ImageContrastAdjustment.jl Documentation","title":"ImageContrastAdjustment.jl Documentation","text":"The usage examples in the ImageContrastAdjustment.jl package assume that you have already installed some key packages. Notably, the examples assume that you are able to load and display an image. Loading an image is facilitated through the FileIO.jl package, which uses QuartzImageIO.jl if you are on MacOS, and ImageMagick.jl otherwise. Depending on your particular system configuration, you might encounter problems installing the image loading packages, in which case you can refer to the troubleshooting guide.","category":"page"},{"location":"#","page":"ImageContrastAdjustment.jl Documentation","title":"ImageContrastAdjustment.jl Documentation","text":"Image display is typically handled by the ImageView.jl package. However, there are some known issues with this package. For example, on Windows the package has the side-effect of introducing substantial input lag when typing in the Julia REPL. Also, as of writing, some users of MacOS are unable to use the ImageView.jl package.","category":"page"},{"location":"#","page":"ImageContrastAdjustment.jl Documentation","title":"ImageContrastAdjustment.jl Documentation","text":"As an alternative, one can display an image using the Makie.jl plotting package. There is also the ImageShow.jl package which facilitates displaying images in Jupyter notebooks via IJulia.jl.","category":"page"},{"location":"#","page":"ImageContrastAdjustment.jl Documentation","title":"ImageContrastAdjustment.jl Documentation","text":"Finally, one can also obtain a useful preview of an image in the REPL using the ImageInTerminal.jl package. However, this package assumes that the terminal uses a monospace font, and tends not to produce adequate results in a Windows environment.","category":"page"},{"location":"#","page":"ImageContrastAdjustment.jl Documentation","title":"ImageContrastAdjustment.jl Documentation","text":"Another package that is used to illustrate the functionality in ImageContrastAdjustment.jl is the TestImages.jl which serves as a repository of many standard image processing test images.","category":"page"},{"location":"#Basic-usage-1","page":"ImageContrastAdjustment.jl Documentation","title":"Basic usage","text":"","category":"section"},{"location":"#","page":"ImageContrastAdjustment.jl Documentation","title":"ImageContrastAdjustment.jl Documentation","text":"Each contrast manipulation algorithm in ImageContrastAdjustment.jl is an AbstractHistogramAdjustmentAlgorithm.","category":"page"},{"location":"#","page":"ImageContrastAdjustment.jl Documentation","title":"ImageContrastAdjustment.jl Documentation","text":"Suppose one wants to enhance the contrast an image. This can be achieved by simply choosing an appropriate algorithm and calling adjust_histogram or adjust_histogram! in the image. The contrast will be automatically enhanced.","category":"page"},{"location":"#","page":"ImageContrastAdjustment.jl Documentation","title":"ImageContrastAdjustment.jl Documentation","text":"Let's see a simple demo:","category":"page"},{"location":"#","page":"ImageContrastAdjustment.jl Documentation","title":"ImageContrastAdjustment.jl Documentation","text":"using TestImages, ImageContrastAdjustment\nusing FileIO # hide\nimg = testimage(\"cameraman\")\nalg = Equalization(nbins = 256)\nimg_adjusted = adjust_histogram(img, alg)\nsave(\"images/demo.jpg\", hcat(img, img_adjusted)) # hide","category":"page"},{"location":"#","page":"ImageContrastAdjustment.jl Documentation","title":"ImageContrastAdjustment.jl Documentation","text":"<img src=\"images/demo.jpg\" width=\"400px\" alt=\"demo image\" />","category":"page"},{"location":"#","page":"ImageContrastAdjustment.jl Documentation","title":"ImageContrastAdjustment.jl Documentation","text":"This usage reads as \"adjust_histogram of the image img with algorithm alg\"","category":"page"},{"location":"#","page":"ImageContrastAdjustment.jl Documentation","title":"ImageContrastAdjustment.jl Documentation","text":"For more advanced usage, please check function reference page.","category":"page"},{"location":"#Examples-1","page":"ImageContrastAdjustment.jl Documentation","title":"Examples","text":"","category":"section"},{"location":"#","page":"ImageContrastAdjustment.jl Documentation","title":"ImageContrastAdjustment.jl Documentation","text":"Below are some examples of contrast adjustment operations that this package facilitates.","category":"page"},{"location":"#","page":"ImageContrastAdjustment.jl Documentation","title":"ImageContrastAdjustment.jl Documentation","text":"<table width=\"500\" border=\"0\" cellpadding=\"5\">\n\n<tr>\n\n<td align=\"center\" valign=\"center\">\n<img src=\"images/contrast_stretching.gif\" width=\"100px\" alt=\"Contrast Stretching\" />\n<br />\nContrast Stretching\n</td>\n\n<td align=\"center\" valign=\"center\">\n<img src=\"images/contrast_stretching_col.gif\" width=\"100px\" alt=\"Contrast Stretching\" />\n<br />\nContrast Stretching\n</td>\n\n</tr>\n\n<tr>\n\n<td align=\"center\" valign=\"center\">\n<img src=\"images/linear_stretching.gif\" width=\"100px\" alt=\"Linear Stretching (Normalization)\" />\n<br />\nLinear Stretching/Normalization\n</td>\n\n<td align=\"center\" valign=\"center\">\n<img src=\"images/linear_stretching_col.gif\" width=\"100px\" alt=\"Linear Stretching (Normalization)\" />\n<br />\nLinear Stretching/Normalization\n</td>\n\n</tr>\n\n<tr>\n\n<td align=\"center\" valign=\"center\">\n<img src=\"images/gamma_correction.gif\" width=\"100px\" alt=\"Gamma Correction\" />\n<br />\nGamma Correction\n</td>\n\n<td align=\"center\" valign=\"center\">\n<img src=\"images/gamma_correction_col.gif\" width=\"100px\" alt=\"Gamma Correction\" />\n<br />\nGamma Correction\n</td>\n\n</tr>\n\n<tr>\n\n<td align=\"center\" valign=\"center\">\n<img src=\"images/equalization.gif\" width=\"100px\" alt=\"Histogram Equalization\" />\n<br />\nHistogram Equalization\n</td>\n\n<td align=\"center\" valign=\"center\">\n<img src=\"images/equalization_col.gif\" width=\"100px\" alt=\"Histogram Equalization\" />\n<br />\nHistogram Equalization\n</td>\n\n</tr>\n\n<tr>\n\n<td align=\"center\" valign=\"center\">\n<img src=\"images/midway_equalization.gif\" width=\"100px\" alt=\"Midway Histogram Equalization\" />\n<br />\nMidway Histogram Equalization\n</td>\n\n<td align=\"center\" valign=\"center\">\n<img src=\"images/midway_equalization_col.gif\" width=\"100px\" alt=\"Midway Histogram Equalization\" />\n<br />\nMidway Histogram Equalization\n</td>\n\n</tr>\n\n<tr>\n\n<td align=\"center\" valign=\"center\">\n<img src=\"images/matching.gif\" width=\"100px\" alt=\"Histogram Matching\" />\n<br />\nHistogram Matching\n</td>\n\n<td align=\"center\" valign=\"center\">\n<img src=\"images/matching_col.gif\" width=\"100px\" alt=\"Histogram Matching\" />\n<br />\nHistogram Matching\n</td>\n\n</tr>\n\n</table>","category":"page"}]
}
